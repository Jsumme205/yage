/* automatically generated by rust-bindgen 0.71.1 */

#![allow(unused)]
#![allow(nonstandard_style)]

#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(C)]
pub struct __BindgenComplex<T> {
    pub re: T,
    pub im: T,
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2Y: u32 = 0;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 41;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 1;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 1;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const WAYLAND_VERSION_MAJOR: u32 = 1;
pub const WAYLAND_VERSION_MINOR: u32 = 23;
pub const WAYLAND_VERSION_MICRO: u32 = 1;
pub const WAYLAND_VERSION: &[u8; 7] = b"1.23.1\0";
pub const WL_MARSHAL_FLAG_DESTROY: u32 = 1;
pub const WL_DISPLAY_SYNC: u32 = 0;
pub const WL_DISPLAY_GET_REGISTRY: u32 = 1;
pub const WL_DISPLAY_ERROR_SINCE_VERSION: u32 = 1;
pub const WL_DISPLAY_DELETE_ID_SINCE_VERSION: u32 = 1;
pub const WL_DISPLAY_SYNC_SINCE_VERSION: u32 = 1;
pub const WL_DISPLAY_GET_REGISTRY_SINCE_VERSION: u32 = 1;
pub const WL_REGISTRY_BIND: u32 = 0;
pub const WL_REGISTRY_GLOBAL_SINCE_VERSION: u32 = 1;
pub const WL_REGISTRY_GLOBAL_REMOVE_SINCE_VERSION: u32 = 1;
pub const WL_REGISTRY_BIND_SINCE_VERSION: u32 = 1;
pub const WL_CALLBACK_DONE_SINCE_VERSION: u32 = 1;
pub const WL_COMPOSITOR_CREATE_SURFACE: u32 = 0;
pub const WL_COMPOSITOR_CREATE_REGION: u32 = 1;
pub const WL_COMPOSITOR_CREATE_SURFACE_SINCE_VERSION: u32 = 1;
pub const WL_COMPOSITOR_CREATE_REGION_SINCE_VERSION: u32 = 1;
pub const WL_SHM_POOL_CREATE_BUFFER: u32 = 0;
pub const WL_SHM_POOL_DESTROY: u32 = 1;
pub const WL_SHM_POOL_RESIZE: u32 = 2;
pub const WL_SHM_POOL_CREATE_BUFFER_SINCE_VERSION: u32 = 1;
pub const WL_SHM_POOL_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_SHM_POOL_RESIZE_SINCE_VERSION: u32 = 1;
pub const WL_SHM_CREATE_POOL: u32 = 0;
pub const WL_SHM_RELEASE: u32 = 1;
pub const WL_SHM_FORMAT_SINCE_VERSION: u32 = 1;
pub const WL_SHM_CREATE_POOL_SINCE_VERSION: u32 = 1;
pub const WL_SHM_RELEASE_SINCE_VERSION: u32 = 2;
pub const WL_BUFFER_DESTROY: u32 = 0;
pub const WL_BUFFER_RELEASE_SINCE_VERSION: u32 = 1;
pub const WL_BUFFER_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_ACCEPT: u32 = 0;
pub const WL_DATA_OFFER_RECEIVE: u32 = 1;
pub const WL_DATA_OFFER_DESTROY: u32 = 2;
pub const WL_DATA_OFFER_FINISH: u32 = 3;
pub const WL_DATA_OFFER_SET_ACTIONS: u32 = 4;
pub const WL_DATA_OFFER_OFFER_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_SOURCE_ACTIONS_SINCE_VERSION: u32 = 3;
pub const WL_DATA_OFFER_ACTION_SINCE_VERSION: u32 = 3;
pub const WL_DATA_OFFER_ACCEPT_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_RECEIVE_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_FINISH_SINCE_VERSION: u32 = 3;
pub const WL_DATA_OFFER_SET_ACTIONS_SINCE_VERSION: u32 = 3;
pub const WL_DATA_SOURCE_OFFER: u32 = 0;
pub const WL_DATA_SOURCE_DESTROY: u32 = 1;
pub const WL_DATA_SOURCE_SET_ACTIONS: u32 = 2;
pub const WL_DATA_SOURCE_TARGET_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_SEND_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_CANCELLED_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_DND_DROP_PERFORMED_SINCE_VERSION: u32 = 3;
pub const WL_DATA_SOURCE_DND_FINISHED_SINCE_VERSION: u32 = 3;
pub const WL_DATA_SOURCE_ACTION_SINCE_VERSION: u32 = 3;
pub const WL_DATA_SOURCE_OFFER_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_SET_ACTIONS_SINCE_VERSION: u32 = 3;
pub const WL_DATA_DEVICE_START_DRAG: u32 = 0;
pub const WL_DATA_DEVICE_SET_SELECTION: u32 = 1;
pub const WL_DATA_DEVICE_RELEASE: u32 = 2;
pub const WL_DATA_DEVICE_DATA_OFFER_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_ENTER_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_LEAVE_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_MOTION_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_DROP_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_SELECTION_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_START_DRAG_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_SET_SELECTION_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_RELEASE_SINCE_VERSION: u32 = 2;
pub const WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE: u32 = 0;
pub const WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE: u32 = 1;
pub const WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_GET_SHELL_SURFACE: u32 = 0;
pub const WL_SHELL_GET_SHELL_SURFACE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_PONG: u32 = 0;
pub const WL_SHELL_SURFACE_MOVE: u32 = 1;
pub const WL_SHELL_SURFACE_RESIZE: u32 = 2;
pub const WL_SHELL_SURFACE_SET_TOPLEVEL: u32 = 3;
pub const WL_SHELL_SURFACE_SET_TRANSIENT: u32 = 4;
pub const WL_SHELL_SURFACE_SET_FULLSCREEN: u32 = 5;
pub const WL_SHELL_SURFACE_SET_POPUP: u32 = 6;
pub const WL_SHELL_SURFACE_SET_MAXIMIZED: u32 = 7;
pub const WL_SHELL_SURFACE_SET_TITLE: u32 = 8;
pub const WL_SHELL_SURFACE_SET_CLASS: u32 = 9;
pub const WL_SHELL_SURFACE_PING_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_CONFIGURE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_POPUP_DONE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_PONG_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_MOVE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_RESIZE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_TOPLEVEL_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_TRANSIENT_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_FULLSCREEN_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_POPUP_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_MAXIMIZED_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_TITLE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_CLASS_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_DESTROY: u32 = 0;
pub const WL_SURFACE_ATTACH: u32 = 1;
pub const WL_SURFACE_DAMAGE: u32 = 2;
pub const WL_SURFACE_FRAME: u32 = 3;
pub const WL_SURFACE_SET_OPAQUE_REGION: u32 = 4;
pub const WL_SURFACE_SET_INPUT_REGION: u32 = 5;
pub const WL_SURFACE_COMMIT: u32 = 6;
pub const WL_SURFACE_SET_BUFFER_TRANSFORM: u32 = 7;
pub const WL_SURFACE_SET_BUFFER_SCALE: u32 = 8;
pub const WL_SURFACE_DAMAGE_BUFFER: u32 = 9;
pub const WL_SURFACE_OFFSET: u32 = 10;
pub const WL_SURFACE_ENTER_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_LEAVE_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_PREFERRED_BUFFER_SCALE_SINCE_VERSION: u32 = 6;
pub const WL_SURFACE_PREFERRED_BUFFER_TRANSFORM_SINCE_VERSION: u32 = 6;
pub const WL_SURFACE_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_ATTACH_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_DAMAGE_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_FRAME_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_SET_OPAQUE_REGION_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_SET_INPUT_REGION_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_COMMIT_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_SET_BUFFER_TRANSFORM_SINCE_VERSION: u32 = 2;
pub const WL_SURFACE_SET_BUFFER_SCALE_SINCE_VERSION: u32 = 3;
pub const WL_SURFACE_DAMAGE_BUFFER_SINCE_VERSION: u32 = 4;
pub const WL_SURFACE_OFFSET_SINCE_VERSION: u32 = 5;
pub const WL_SEAT_GET_POINTER: u32 = 0;
pub const WL_SEAT_GET_KEYBOARD: u32 = 1;
pub const WL_SEAT_GET_TOUCH: u32 = 2;
pub const WL_SEAT_RELEASE: u32 = 3;
pub const WL_SEAT_CAPABILITIES_SINCE_VERSION: u32 = 1;
pub const WL_SEAT_NAME_SINCE_VERSION: u32 = 2;
pub const WL_SEAT_GET_POINTER_SINCE_VERSION: u32 = 1;
pub const WL_SEAT_GET_KEYBOARD_SINCE_VERSION: u32 = 1;
pub const WL_SEAT_GET_TOUCH_SINCE_VERSION: u32 = 1;
pub const WL_SEAT_RELEASE_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_AXIS_SOURCE_WHEEL_TILT_SINCE_VERSION: u32 = 6;
pub const WL_POINTER_SET_CURSOR: u32 = 0;
pub const WL_POINTER_RELEASE: u32 = 1;
pub const WL_POINTER_ENTER_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_LEAVE_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_MOTION_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_BUTTON_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_AXIS_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_FRAME_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_AXIS_SOURCE_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_AXIS_STOP_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_AXIS_DISCRETE_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_AXIS_VALUE120_SINCE_VERSION: u32 = 8;
pub const WL_POINTER_AXIS_RELATIVE_DIRECTION_SINCE_VERSION: u32 = 9;
pub const WL_POINTER_SET_CURSOR_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_RELEASE_SINCE_VERSION: u32 = 3;
pub const WL_KEYBOARD_RELEASE: u32 = 0;
pub const WL_KEYBOARD_KEYMAP_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_ENTER_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_LEAVE_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_KEY_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_MODIFIERS_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_REPEAT_INFO_SINCE_VERSION: u32 = 4;
pub const WL_KEYBOARD_RELEASE_SINCE_VERSION: u32 = 3;
pub const WL_TOUCH_RELEASE: u32 = 0;
pub const WL_TOUCH_DOWN_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_UP_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_MOTION_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_FRAME_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_CANCEL_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_SHAPE_SINCE_VERSION: u32 = 6;
pub const WL_TOUCH_ORIENTATION_SINCE_VERSION: u32 = 6;
pub const WL_TOUCH_RELEASE_SINCE_VERSION: u32 = 3;
pub const WL_OUTPUT_RELEASE: u32 = 0;
pub const WL_OUTPUT_GEOMETRY_SINCE_VERSION: u32 = 1;
pub const WL_OUTPUT_MODE_SINCE_VERSION: u32 = 1;
pub const WL_OUTPUT_DONE_SINCE_VERSION: u32 = 2;
pub const WL_OUTPUT_SCALE_SINCE_VERSION: u32 = 2;
pub const WL_OUTPUT_NAME_SINCE_VERSION: u32 = 4;
pub const WL_OUTPUT_DESCRIPTION_SINCE_VERSION: u32 = 4;
pub const WL_OUTPUT_RELEASE_SINCE_VERSION: u32 = 3;
pub const WL_REGION_DESTROY: u32 = 0;
pub const WL_REGION_ADD: u32 = 1;
pub const WL_REGION_SUBTRACT: u32 = 2;
pub const WL_REGION_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_REGION_ADD_SINCE_VERSION: u32 = 1;
pub const WL_REGION_SUBTRACT_SINCE_VERSION: u32 = 1;
pub const WL_SUBCOMPOSITOR_DESTROY: u32 = 0;
pub const WL_SUBCOMPOSITOR_GET_SUBSURFACE: u32 = 1;
pub const WL_SUBCOMPOSITOR_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_SUBCOMPOSITOR_GET_SUBSURFACE_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_DESTROY: u32 = 0;
pub const WL_SUBSURFACE_SET_POSITION: u32 = 1;
pub const WL_SUBSURFACE_PLACE_ABOVE: u32 = 2;
pub const WL_SUBSURFACE_PLACE_BELOW: u32 = 3;
pub const WL_SUBSURFACE_SET_SYNC: u32 = 4;
pub const WL_SUBSURFACE_SET_DESYNC: u32 = 5;
pub const WL_SUBSURFACE_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_SET_POSITION_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_PLACE_ABOVE_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_PLACE_BELOW_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_SET_SYNC_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_SET_DESYNC_SINCE_VERSION: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const WL_DISPLAY_ERROR: u32 = 0;
pub const WL_DISPLAY_DELETE_ID: u32 = 1;
pub const WL_REGISTRY_GLOBAL: u32 = 0;
pub const WL_REGISTRY_GLOBAL_REMOVE: u32 = 1;
pub const WL_CALLBACK_DONE: u32 = 0;
pub const WL_SHM_FORMAT: u32 = 0;
pub const WL_BUFFER_RELEASE: u32 = 0;
pub const WL_DATA_OFFER_OFFER: u32 = 0;
pub const WL_DATA_OFFER_SOURCE_ACTIONS: u32 = 1;
pub const WL_DATA_OFFER_ACTION: u32 = 2;
pub const WL_DATA_SOURCE_TARGET: u32 = 0;
pub const WL_DATA_SOURCE_SEND: u32 = 1;
pub const WL_DATA_SOURCE_CANCELLED: u32 = 2;
pub const WL_DATA_SOURCE_DND_DROP_PERFORMED: u32 = 3;
pub const WL_DATA_SOURCE_DND_FINISHED: u32 = 4;
pub const WL_DATA_SOURCE_ACTION: u32 = 5;
pub const WL_DATA_DEVICE_DATA_OFFER: u32 = 0;
pub const WL_DATA_DEVICE_ENTER: u32 = 1;
pub const WL_DATA_DEVICE_LEAVE: u32 = 2;
pub const WL_DATA_DEVICE_MOTION: u32 = 3;
pub const WL_DATA_DEVICE_DROP: u32 = 4;
pub const WL_DATA_DEVICE_SELECTION: u32 = 5;
pub const WL_SHELL_SURFACE_PING: u32 = 0;
pub const WL_SHELL_SURFACE_CONFIGURE: u32 = 1;
pub const WL_SHELL_SURFACE_POPUP_DONE: u32 = 2;
pub const WL_SURFACE_ENTER: u32 = 0;
pub const WL_SURFACE_LEAVE: u32 = 1;
pub const WL_SURFACE_PREFERRED_BUFFER_SCALE: u32 = 2;
pub const WL_SURFACE_PREFERRED_BUFFER_TRANSFORM: u32 = 3;
pub const WL_SEAT_CAPABILITIES: u32 = 0;
pub const WL_SEAT_NAME: u32 = 1;
pub const WL_POINTER_ENTER: u32 = 0;
pub const WL_POINTER_LEAVE: u32 = 1;
pub const WL_POINTER_MOTION: u32 = 2;
pub const WL_POINTER_BUTTON: u32 = 3;
pub const WL_POINTER_AXIS: u32 = 4;
pub const WL_POINTER_FRAME: u32 = 5;
pub const WL_POINTER_AXIS_SOURCE: u32 = 6;
pub const WL_POINTER_AXIS_STOP: u32 = 7;
pub const WL_POINTER_AXIS_DISCRETE: u32 = 8;
pub const WL_POINTER_AXIS_VALUE120: u32 = 9;
pub const WL_POINTER_AXIS_RELATIVE_DIRECTION: u32 = 10;
pub const WL_KEYBOARD_KEYMAP: u32 = 0;
pub const WL_KEYBOARD_ENTER: u32 = 1;
pub const WL_KEYBOARD_LEAVE: u32 = 2;
pub const WL_KEYBOARD_KEY: u32 = 3;
pub const WL_KEYBOARD_MODIFIERS: u32 = 4;
pub const WL_KEYBOARD_REPEAT_INFO: u32 = 5;
pub const WL_TOUCH_DOWN: u32 = 0;
pub const WL_TOUCH_UP: u32 = 1;
pub const WL_TOUCH_MOTION: u32 = 2;
pub const WL_TOUCH_FRAME: u32 = 3;
pub const WL_TOUCH_CANCEL: u32 = 4;
pub const WL_TOUCH_SHAPE: u32 = 5;
pub const WL_TOUCH_ORIENTATION: u32 = 6;
pub const WL_OUTPUT_GEOMETRY: u32 = 0;
pub const WL_OUTPUT_MODE: u32 = 1;
pub const WL_OUTPUT_DONE: u32 = 2;
pub const WL_OUTPUT_SCALE: u32 = 3;
pub const WL_OUTPUT_NAME: u32 = 4;
pub const WL_OUTPUT_DESCRIPTION: u32 = 5;
pub const WL_EGL_PLATFORM: u32 = 1;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::core::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::core::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::core::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __cfloat128 = __BindgenComplex<u128>;
pub type _Float128 = u128;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type float_t = f32;
pub type double_t = f64;
unsafe extern "C" {
    pub fn __fpclassify(__value: f64) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __signbit(__value: f64) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __isinf(__value: f64) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __finite(__value: f64) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __isnan(__value: f64) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __issignaling(__value: f64) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn acos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn asin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
unsafe extern "C" {
    pub fn cos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn tan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::core::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::core::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::core::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::core::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn log(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn logb(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn floor(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn isinf(__value: f64) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn finite(__value: f64) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn significand(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nan(__tagb: *const ::core::ffi::c_char) -> f64;
}
unsafe extern "C" {
    pub fn __nan(__tagb: *const ::core::ffi::c_char) -> f64;
}
unsafe extern "C" {
    pub fn isnan(__value: f64) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn jn(arg1: ::core::ffi::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn __jn(arg1: ::core::ffi::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn yn(arg1: ::core::ffi::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn __yn(arg1: ::core::ffi::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::core::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::core::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn rint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalbn(__x: f64, __n: ::core::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __scalbn(__x: f64, __n: ::core::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ilogb(__x: f64) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __ilogb(__x: f64) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn scalbln(__x: f64, __n: ::core::ffi::c_long) -> f64;
}
unsafe extern "C" {
    pub fn __scalbln(__x: f64, __n: ::core::ffi::c_long) -> f64;
}
unsafe extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn round(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::core::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::core::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn lrint(__x: f64) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn __lrint(__x: f64) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn llrint(__x: f64) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn __llrint(__x: f64) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn lround(__x: f64) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn __lround(__x: f64) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn llround(__x: f64) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn __llround(__x: f64) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
unsafe extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __signbitf(__value: f32) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __isinff(__value: f32) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __finitef(__value: f32) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __isnanf(__value: f32) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __issignalingf(__value: f32) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
unsafe extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn expf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::core::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::core::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::core::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::core::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn logf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn isinff(__value: f32) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn finitef(__value: f32) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nanf(__tagb: *const ::core::ffi::c_char) -> f32;
}
unsafe extern "C" {
    pub fn __nanf(__tagb: *const ::core::ffi::c_char) -> f32;
}
unsafe extern "C" {
    pub fn isnanf(__value: f32) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn jnf(arg1: ::core::ffi::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn __jnf(arg1: ::core::ffi::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn ynf(arg1: ::core::ffi::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn __ynf(arg1: ::core::ffi::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::core::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::core::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn scalbnf(__x: f32, __n: ::core::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::core::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ilogbf(__x: f32) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf(__x: f32) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn scalblnf(__x: f32, __n: ::core::ffi::c_long) -> f32;
}
unsafe extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::core::ffi::c_long) -> f32;
}
unsafe extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::core::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::core::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn lrintf(__x: f32) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn __lrintf(__x: f32) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn llrintf(__x: f32) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf(__x: f32) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf(__x: f32) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn __lroundf(__x: f32) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn llroundf(__x: f32) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf(__x: f32) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
unsafe extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
unsafe extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __signbitl(__value: u128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __isinfl(__value: u128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __finitel(__value: u128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __isnanl(__value: u128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __issignalingl(__value: u128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
unsafe extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn expl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::core::ffi::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::core::ffi::c_int) -> u128;
}
unsafe extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::core::ffi::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::core::ffi::c_int) -> u128;
}
unsafe extern "C" {
    pub fn logl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
unsafe extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
unsafe extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn isinfl(__value: u128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn finitel(__value: u128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nanl(__tagb: *const ::core::ffi::c_char) -> u128;
}
unsafe extern "C" {
    pub fn __nanl(__tagb: *const ::core::ffi::c_char) -> u128;
}
unsafe extern "C" {
    pub fn isnanl(__value: u128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn jnl(arg1: ::core::ffi::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn __jnl(arg1: ::core::ffi::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn ynl(arg1: ::core::ffi::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn __ynl(arg1: ::core::ffi::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::core::ffi::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::core::ffi::c_int) -> u128;
}
unsafe extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn scalbnl(__x: u128, __n: ::core::ffi::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::core::ffi::c_int) -> u128;
}
unsafe extern "C" {
    pub fn ilogbl(__x: u128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __ilogbl(__x: u128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn scalblnl(__x: u128, __n: ::core::ffi::c_long) -> u128;
}
unsafe extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::core::ffi::c_long) -> u128;
}
unsafe extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::core::ffi::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::core::ffi::c_int) -> u128;
}
unsafe extern "C" {
    pub fn lrintl(__x: u128) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn __lrintl(__x: u128) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn llrintl(__x: u128) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintl(__x: u128) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn lroundl(__x: u128) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn __lroundl(__x: u128) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn llroundl(__x: u128) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundl(__x: u128) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
unsafe extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
unsafe extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fpclassifyf128(__value: _Float128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __signbitf128(__value: _Float128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __isinff128(__value: _Float128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __finitef128(__value: _Float128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __isnanf128(__value: _Float128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigf128(__x: _Float128, __y: _Float128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __issignalingf128(__value: _Float128) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub static mut signgam: ::core::ffi::c_int;
}
pub const FP_NAN: _bindgen_ty_1 = 0;
pub const FP_INFINITE: _bindgen_ty_1 = 1;
pub const FP_ZERO: _bindgen_ty_1 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_1 = 3;
pub const FP_NORMAL: _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::core::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::core::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::core::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::core::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __gwchar_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::core::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::core::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::core::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::core::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
unsafe extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::core::ffi::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::core::ffi::c_int,
    ) -> uintmax_t;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
#[doc = " Protocol message signature\n\n A wl_message describes the signature of an actual protocol message, such as a\n request or event, that adheres to the Wayland protocol wire format. The\n protocol implementation uses a wl_message within its demarshal machinery for\n decoding messages between a compositor and its clients. In a sense, a\n wl_message is to a protocol message like a class is to an object.\n\n The `name` of a wl_message is the name of the corresponding protocol message.\n\n The `signature` is an ordered list of symbols representing the data types\n of message arguments and, optionally, a protocol version and indicators for\n nullability. A leading integer in the `signature` indicates the _since_\n version of the protocol message. A `?` preceding a data type symbol indicates\n that the following argument type is nullable. While it is a protocol violation\n to send messages with non-nullable arguments set to `NULL`, event handlers in\n clients might still get called with non-nullable object arguments set to\n `NULL`. This can happen when the client destroyed the object being used as\n argument on its side and an event referencing that object was sent before the\n server knew about its destruction. As this race cannot be prevented, clients\n should - as a general rule - program their event handlers such that they can\n handle object arguments declared non-nullable being `NULL` gracefully.\n\n When no arguments accompany a message, `signature` is an empty string.\n\n Symbols:\n\n * `i`: int\n * `u`: uint\n * `f`: fixed\n * `s`: string\n * `o`: object\n * `n`: new_id\n * `a`: array\n * `h`: fd\n * `?`: following argument (`o` or `s`) is nullable\n\n While demarshaling primitive arguments is straightforward, when demarshaling\n messages containing `object` or `new_id` arguments, the protocol\n implementation often must determine the type of the object. The `types` of a\n wl_message is an array of wl_interface references that correspond to `o` and\n `n` arguments in `signature`, with `NULL` placeholders for arguments with\n non-object types.\n\n Consider the protocol event wl_display `delete_id` that has a single `uint`\n argument. The wl_message is:\n\n \\code\n { \"delete_id\", \"u\", [NULL] }\n \\endcode\n\n Here, the message `name` is `\"delete_id\"`, the `signature` is `\"u\"`, and the\n argument `types` is `[NULL]`, indicating that the `uint` argument has no\n corresponding wl_interface since it is a primitive argument.\n\n In contrast, consider a `wl_foo` interface supporting protocol request `bar`\n that has existed since version 2, and has two arguments: a `uint` and an\n object of type `wl_baz_interface` that may be `NULL`. Such a `wl_message`\n might be:\n\n \\code\n { \"bar\", \"2u?o\", [NULL, &wl_baz_interface] }\n \\endcode\n\n Here, the message `name` is `\"bar\"`, and the `signature` is `\"2u?o\"`. Notice\n how the `2` indicates the protocol version, the `u` indicates the first\n argument type is `uint`, and the `?o` indicates that the second argument\n is an object that may be `NULL`. Lastly, the argument `types` array indicates\n that no wl_interface corresponds to the first argument, while the type\n `wl_baz_interface` corresponds to the second argument.\n\n \\sa wl_argument\n \\sa wl_interface\n \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Wire-Format\">Wire Format</a>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_message {
    #[doc = " Message name"]
    pub name: *const ::core::ffi::c_char,
    #[doc = " Message signature"]
    pub signature: *const ::core::ffi::c_char,
    #[doc = " Object argument interfaces"]
    pub types: *mut *const wl_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_message"][::core::mem::size_of::<wl_message>() - 24usize];
    ["Alignment of wl_message"][::core::mem::align_of::<wl_message>() - 8usize];
    ["Offset of field: wl_message::name"][::core::mem::offset_of!(wl_message, name) - 0usize];
    ["Offset of field: wl_message::signature"]
        [::core::mem::offset_of!(wl_message, signature) - 8usize];
    ["Offset of field: wl_message::types"][::core::mem::offset_of!(wl_message, types) - 16usize];
};
#[doc = " Protocol object interface\n\n A wl_interface describes the API of a protocol object defined in the Wayland\n protocol specification. The protocol implementation uses a wl_interface\n within its marshalling machinery for encoding client requests.\n\n The `name` of a wl_interface is the name of the corresponding protocol\n interface, and `version` represents the version of the interface. The members\n `method_count` and `event_count` represent the number of `methods` (requests)\n and `events` in the respective wl_message members.\n\n For example, consider a protocol interface `foo`, marked as version `1`, with\n two requests and one event.\n\n \\code{.xml}\n <interface name=\"foo\" version=\"1\">\n   <request name=\"a\"></request>\n   <request name=\"b\"></request>\n   <event name=\"c\"></event>\n </interface>\n \\endcode\n\n Given two wl_message arrays `foo_requests` and `foo_events`, a wl_interface\n for `foo` might be:\n\n \\code\n struct wl_interface foo_interface = {\n         \"foo\", 1,\n         2, foo_requests,\n         1, foo_events\n };\n \\endcode\n\n \\note The server side of the protocol may define interface <em>implementation\n       types</em> that incorporate the term `interface` in their name. Take\n       care to not confuse these server-side `struct`s with a wl_interface\n       variable whose name also ends in `interface`. For example, while the\n       server may define a type `struct wl_foo_interface`, the client may\n       define a `struct wl_interface wl_foo_interface`.\n\n \\sa wl_message\n \\sa wl_proxy\n \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Interfaces\">Interfaces</a>\n \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Versioning\">Versioning</a>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_interface {
    #[doc = " Interface name"]
    pub name: *const ::core::ffi::c_char,
    #[doc = " Interface version"]
    pub version: ::core::ffi::c_int,
    #[doc = " Number of methods (requests)"]
    pub method_count: ::core::ffi::c_int,
    #[doc = " Method (request) signatures"]
    pub methods: *const wl_message,
    #[doc = " Number of events"]
    pub event_count: ::core::ffi::c_int,
    #[doc = " Event signatures"]
    pub events: *const wl_message,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_interface"][::core::mem::size_of::<wl_interface>() - 40usize];
    ["Alignment of wl_interface"][::core::mem::align_of::<wl_interface>() - 8usize];
    ["Offset of field: wl_interface::name"][::core::mem::offset_of!(wl_interface, name) - 0usize];
    ["Offset of field: wl_interface::version"]
        [::core::mem::offset_of!(wl_interface, version) - 8usize];
    ["Offset of field: wl_interface::method_count"]
        [::core::mem::offset_of!(wl_interface, method_count) - 12usize];
    ["Offset of field: wl_interface::methods"]
        [::core::mem::offset_of!(wl_interface, methods) - 16usize];
    ["Offset of field: wl_interface::event_count"]
        [::core::mem::offset_of!(wl_interface, event_count) - 24usize];
    ["Offset of field: wl_interface::events"]
        [::core::mem::offset_of!(wl_interface, events) - 32usize];
};
#[doc = " \\class wl_list\n\n \\brief Doubly-linked list\n\n On its own, an instance of `struct wl_list` represents the sentinel head of\n a doubly-linked list, and must be initialized using wl_list_init().\n When empty, the list head's `next` and `prev` members point to the list head\n itself, otherwise `next` references the first element in the list, and `prev`\n refers to the last element in the list.\n\n Use the `struct wl_list` type to represent both the list head and the links\n between elements within the list. Use wl_list_empty() to determine if the\n list is empty in O(1).\n\n All elements in the list must be of the same type. The element type must have\n a `struct wl_list` member, often named `link` by convention. Prior to\n insertion, there is no need to initialize an element's `link` - invoking\n wl_list_init() on an individual list element's `struct wl_list` member is\n unnecessary if the very next operation is wl_list_insert(). However, a\n common idiom is to initialize an element's `link` prior to removal - ensure\n safety by invoking wl_list_init() before wl_list_remove().\n\n Consider a list reference `struct wl_list foo_list`, an element type as\n `struct element`, and an element's link member as `struct wl_list link`.\n\n The following code initializes a list and adds three elements to it.\n\n \\code\n struct wl_list foo_list;\n\n struct element {\n         int foo;\n         struct wl_list link;\n };\n struct element e1, e2, e3;\n\n wl_list_init(&foo_list);\n wl_list_insert(&foo_list, &e1.link);   // e1 is the first element\n wl_list_insert(&foo_list, &e2.link);   // e2 is now the first element\n wl_list_insert(&e2.link, &e3.link); // insert e3 after e2\n \\endcode\n\n The list now looks like <em>[e2, e3, e1]</em>.\n\n The `wl_list` API provides some iterator macros. For example, to iterate\n a list in ascending order:\n\n \\code\n struct element *e;\n wl_list_for_each(e, foo_list, link) {\n         do_something_with_element(e);\n }\n \\endcode\n\n See the documentation of each iterator for details.\n \\sa http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/list.h"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_list {
    #[doc = " Previous list element"]
    pub prev: *mut wl_list,
    #[doc = " Next list element"]
    pub next: *mut wl_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_list"][::core::mem::size_of::<wl_list>() - 16usize];
    ["Alignment of wl_list"][::core::mem::align_of::<wl_list>() - 8usize];
    ["Offset of field: wl_list::prev"][::core::mem::offset_of!(wl_list, prev) - 0usize];
    ["Offset of field: wl_list::next"][::core::mem::offset_of!(wl_list, next) - 8usize];
};
unsafe extern "C" {
    #[doc = " Initializes the list.\n\n \\param list List to initialize\n\n \\memberof wl_list"]
    pub fn wl_list_init(list: *mut wl_list);
}
unsafe extern "C" {
    #[doc = " Inserts an element into the list, after the element represented by \\p list.\n When \\p list is a reference to the list itself (the head), set the containing\n struct of \\p elm as the first element in the list.\n\n \\note If \\p elm is already part of a list, inserting it again will lead to\n       list corruption.\n\n \\param list List element after which the new element is inserted\n \\param elm Link of the containing struct to insert into the list\n\n \\memberof wl_list"]
    pub fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
}
unsafe extern "C" {
    #[doc = " Removes an element from the list.\n\n \\note This operation leaves \\p elm in an invalid state.\n\n \\param elm Link of the containing struct to remove from the list\n\n \\memberof wl_list"]
    pub fn wl_list_remove(elm: *mut wl_list);
}
unsafe extern "C" {
    #[doc = " Determines the length of the list.\n\n \\note This is an O(n) operation.\n\n \\param list List whose length is to be determined\n\n \\return Number of elements in the list\n\n \\memberof wl_list"]
    pub fn wl_list_length(list: *const wl_list) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Determines if the list is empty.\n\n \\param list List whose emptiness is to be determined\n\n \\return 1 if empty, or 0 if not empty\n\n \\memberof wl_list"]
    pub fn wl_list_empty(list: *const wl_list) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " Inserts all of the elements of one list into another, after the element\n represented by \\p list.\n\n \\note This leaves \\p other in an invalid state.\n\n \\param list List element after which the other list elements will be inserted\n \\param other List of elements to insert\n\n \\memberof wl_list"]
    pub fn wl_list_insert_list(list: *mut wl_list, other: *mut wl_list);
}
#[doc = " \\class wl_array\n\n Dynamic array\n\n A wl_array is a dynamic array that can only grow until released. It is\n intended for relatively small allocations whose size is variable or not known\n in advance. While construction of a wl_array does not require all elements to\n be of the same size, wl_array_for_each() does require all elements to have\n the same type and size.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_array {
    #[doc = " Array size"]
    pub size: usize,
    #[doc = " Allocated space"]
    pub alloc: usize,
    #[doc = " Array data"]
    pub data: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_array"][::core::mem::size_of::<wl_array>() - 24usize];
    ["Alignment of wl_array"][::core::mem::align_of::<wl_array>() - 8usize];
    ["Offset of field: wl_array::size"][::core::mem::offset_of!(wl_array, size) - 0usize];
    ["Offset of field: wl_array::alloc"][::core::mem::offset_of!(wl_array, alloc) - 8usize];
    ["Offset of field: wl_array::data"][::core::mem::offset_of!(wl_array, data) - 16usize];
};
unsafe extern "C" {
    #[doc = " Initializes the array.\n\n \\param array Array to initialize\n\n \\memberof wl_array"]
    pub fn wl_array_init(array: *mut wl_array);
}
unsafe extern "C" {
    #[doc = " Releases the array data.\n\n \\note Leaves the array in an invalid state.\n\n \\param array Array whose data is to be released\n\n \\memberof wl_array"]
    pub fn wl_array_release(array: *mut wl_array);
}
unsafe extern "C" {
    #[doc = " Increases the size of the array by \\p size bytes.\n\n \\param array Array whose size is to be increased\n \\param size Number of bytes to increase the size of the array by\n\n \\return A pointer to the beginning of the newly appended space, or NULL when\n         resizing fails.\n\n \\memberof wl_array"]
    pub fn wl_array_add(array: *mut wl_array, size: usize) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Copies the contents of \\p source to \\p array.\n\n \\param array Destination array to copy to\n \\param source Source array to copy from\n\n \\return 0 on success, or -1 on failure\n\n \\memberof wl_array"]
    pub fn wl_array_copy(array: *mut wl_array, source: *mut wl_array) -> ::core::ffi::c_int;
}
#[doc = " Fixed-point number\n\n A `wl_fixed_t` is a 24.8 signed fixed-point number with a sign bit, 23 bits\n of integer precision and 8 bits of decimal precision. Consider `wl_fixed_t`\n as an opaque struct with methods that facilitate conversion to and from\n `double` and `int` types."]
pub type wl_fixed_t = i32;
#[doc = " Protocol message argument data types\n\n This union represents all of the argument types in the Wayland protocol wire\n format. The protocol implementation uses wl_argument within its marshalling\n machinery for dispatching messages between a client and a compositor.\n\n \\sa wl_message\n \\sa wl_interface\n \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-wire-Format\">Wire Format</a>"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union wl_argument {
    #[doc = "< `int`"]
    pub i: i32,
    #[doc = "< `uint`"]
    pub u: u32,
    #[doc = "< `fixed`"]
    pub f: wl_fixed_t,
    #[doc = "< `string`"]
    pub s: *const ::core::ffi::c_char,
    #[doc = "< `object`"]
    pub o: *mut wl_object,
    #[doc = "< `new_id`"]
    pub n: u32,
    #[doc = "< `array`"]
    pub a: *mut wl_array,
    #[doc = "< `fd`"]
    pub h: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_argument"][::core::mem::size_of::<wl_argument>() - 8usize];
    ["Alignment of wl_argument"][::core::mem::align_of::<wl_argument>() - 8usize];
    ["Offset of field: wl_argument::i"][::core::mem::offset_of!(wl_argument, i) - 0usize];
    ["Offset of field: wl_argument::u"][::core::mem::offset_of!(wl_argument, u) - 0usize];
    ["Offset of field: wl_argument::f"][::core::mem::offset_of!(wl_argument, f) - 0usize];
    ["Offset of field: wl_argument::s"][::core::mem::offset_of!(wl_argument, s) - 0usize];
    ["Offset of field: wl_argument::o"][::core::mem::offset_of!(wl_argument, o) - 0usize];
    ["Offset of field: wl_argument::n"][::core::mem::offset_of!(wl_argument, n) - 0usize];
    ["Offset of field: wl_argument::a"][::core::mem::offset_of!(wl_argument, a) - 0usize];
    ["Offset of field: wl_argument::h"][::core::mem::offset_of!(wl_argument, h) - 0usize];
};
#[doc = " Dispatcher function type alias\n\n A dispatcher is a function that handles the emitting of callbacks in client\n code. For programs directly using the C library, this is done by using\n libffi to call function pointers. When binding to languages other than C,\n dispatchers provide a way to abstract the function calling process to be\n friendlier to other function calling systems.\n\n A dispatcher takes five arguments: The first is the dispatcher-specific\n implementation associated with the target object. The second is the object\n upon which the callback is being invoked (either wl_proxy or wl_resource).\n The third and fourth arguments are the opcode and the wl_message\n corresponding to the callback. The final argument is an array of arguments\n received from the other process via the wire protocol.\n\n \\param user_data Dispatcher-specific implementation data\n \\param target Callback invocation target (wl_proxy or `wl_resource`)\n \\param opcode Callback opcode\n \\param msg Callback message signature\n \\param args Array of received arguments\n\n \\return 0 on success, or -1 on failure"]
pub type wl_dispatcher_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        user_data: *const ::core::ffi::c_void,
        target: *mut ::core::ffi::c_void,
        opcode: u32,
        msg: *const wl_message,
        args: *mut wl_argument,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Log function type alias\n\n The C implementation of the Wayland protocol abstracts the details of\n logging. Users may customize the logging behavior, with a function conforming\n to the `wl_log_func_t` type, via `wl_log_set_handler_client` and\n `wl_log_set_handler_server`.\n\n A `wl_log_func_t` must conform to the expectations of `vprintf`, and\n expects two arguments: a string to write and a corresponding variable\n argument list. While the string to write may contain format specifiers and\n use values in the variable argument list, the behavior of any `wl_log_func_t`\n depends on the implementation.\n\n \\note Take care to not confuse this with `wl_protocol_logger_func_t`, which\n       is a specific server-side logger for requests and events.\n\n \\param fmt String to write to the log, containing optional format\n            specifiers\n \\param args Variable argument list\n\n \\sa wl_log_set_handler_client\n \\sa wl_log_set_handler_server"]
pub type wl_log_func_t = ::core::option::Option<
    unsafe extern "C" fn(fmt: *const ::core::ffi::c_char, args: *mut __va_list_tag),
>;
#[doc = " Stop the iteration"]
pub const wl_iterator_result_WL_ITERATOR_STOP: wl_iterator_result = 0;
#[doc = " Continue the iteration"]
pub const wl_iterator_result_WL_ITERATOR_CONTINUE: wl_iterator_result = 1;
#[doc = " Return value of an iterator function\n\n \\sa wl_client_for_each_resource_iterator_func_t\n \\sa wl_client_for_each_resource"]
pub type wl_iterator_result = ::core::ffi::c_uint;
#[doc = " \\class wl_proxy\n\n \\brief Represents a protocol object on the client side.\n\n A wl_proxy acts as a client side proxy to an object existing in the\n compositor. The proxy is responsible for converting requests made by the\n clients with \\ref wl_proxy_marshal() into Wayland's wire format. Events\n coming from the compositor are also handled by the proxy, which will in\n turn call the handler set with \\ref wl_proxy_add_listener().\n\n \\note With the exception of function \\ref wl_proxy_set_queue(), functions\n accessing a wl_proxy are not normally used by client code. Clients\n should normally use the higher level interface generated by the scanner to\n interact with compositor objects.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_proxy {
    _unused: [u8; 0],
}
#[doc = " \\class wl_display\n\n \\brief Represents a connection to the compositor and acts as a proxy to\n the wl_display singleton object.\n\n A wl_display object represents a client connection to a Wayland\n compositor. It is created with either \\ref wl_display_connect() or\n \\ref wl_display_connect_to_fd(). A connection is terminated using\n \\ref wl_display_disconnect().\n\n A wl_display is also used as the \\ref wl_proxy for the wl_display\n singleton object on the compositor side.\n\n A wl_display object handles all the data sent from and to the\n compositor. When a \\ref wl_proxy marshals a request, it will write its wire\n representation to the display's write buffer. The data is sent to the\n compositor when the client calls \\ref wl_display_flush().\n\n Incoming data is handled in two steps: queueing and dispatching. In the\n queue step, the data coming from the display fd is interpreted and\n added to a queue. On the dispatch step, the handler for the incoming\n event set by the client on the corresponding \\ref wl_proxy is called.\n\n A wl_display has at least one event queue, called the <em>default\n queue</em>. Clients can create additional event queues with \\ref\n wl_display_create_queue() and assign \\ref wl_proxy's to it. Events\n occurring in a particular proxy are always queued in its assigned queue.\n A client can ensure that a certain assumption, such as holding a lock\n or running from a given thread, is true when a proxy event handler is\n called by assigning that proxy to an event queue and making sure that\n this queue is only dispatched when the assumption holds.\n\n The default queue is dispatched by calling \\ref wl_display_dispatch().\n This will dispatch any events queued on the default queue and attempt\n to read from the display fd if it's empty. Events read are then queued\n on the appropriate queues according to the proxy assignment.\n\n A user created queue is dispatched with \\ref wl_display_dispatch_queue().\n This function behaves exactly the same as wl_display_dispatch()\n but it dispatches given queue instead of the default queue.\n\n A real world example of event queue usage is Mesa's implementation of\n eglSwapBuffers() for the Wayland platform. This function might need\n to block until a frame callback is received, but dispatching the default\n queue could cause an event handler on the client to start drawing\n again. This problem is solved using another event queue, so that only\n the events handled by the EGL code are dispatched during the block.\n\n This creates a problem where a thread dispatches a non-default\n queue, reading all the data from the display fd. If the application\n would call \\em poll(2) after that it would block, even though there\n might be events queued on the default queue. Those events should be\n dispatched with \\ref wl_display_dispatch_pending() or \\ref\n wl_display_dispatch_queue_pending() before flushing and blocking."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_display {
    _unused: [u8; 0],
}
#[doc = " \\class wl_event_queue\n\n \\brief A queue for \\ref wl_proxy object events.\n\n Event queues allows the events on a display to be handled in a thread-safe\n manner. See \\ref wl_display for details.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_event_queue {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn wl_event_queue_destroy(queue: *mut wl_event_queue);
}
unsafe extern "C" {
    pub fn wl_proxy_marshal_flags(
        proxy: *mut wl_proxy,
        opcode: u32,
        interface: *const wl_interface,
        version: u32,
        flags: u32,
        ...
    ) -> *mut wl_proxy;
}
unsafe extern "C" {
    pub fn wl_proxy_marshal_array_flags(
        proxy: *mut wl_proxy,
        opcode: u32,
        interface: *const wl_interface,
        version: u32,
        flags: u32,
        args: *mut wl_argument,
    ) -> *mut wl_proxy;
}
unsafe extern "C" {
    pub fn wl_proxy_marshal(p: *mut wl_proxy, opcode: u32, ...);
}
unsafe extern "C" {
    pub fn wl_proxy_marshal_array(p: *mut wl_proxy, opcode: u32, args: *mut wl_argument);
}
unsafe extern "C" {
    pub fn wl_proxy_create(factory: *mut wl_proxy, interface: *const wl_interface)
        -> *mut wl_proxy;
}
unsafe extern "C" {
    pub fn wl_proxy_create_wrapper(proxy: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn wl_proxy_wrapper_destroy(proxy_wrapper: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    pub fn wl_proxy_marshal_constructor(
        proxy: *mut wl_proxy,
        opcode: u32,
        interface: *const wl_interface,
        ...
    ) -> *mut wl_proxy;
}
unsafe extern "C" {
    pub fn wl_proxy_marshal_constructor_versioned(
        proxy: *mut wl_proxy,
        opcode: u32,
        interface: *const wl_interface,
        version: u32,
        ...
    ) -> *mut wl_proxy;
}
unsafe extern "C" {
    pub fn wl_proxy_marshal_array_constructor(
        proxy: *mut wl_proxy,
        opcode: u32,
        args: *mut wl_argument,
        interface: *const wl_interface,
    ) -> *mut wl_proxy;
}
unsafe extern "C" {
    pub fn wl_proxy_marshal_array_constructor_versioned(
        proxy: *mut wl_proxy,
        opcode: u32,
        args: *mut wl_argument,
        interface: *const wl_interface,
        version: u32,
    ) -> *mut wl_proxy;
}
unsafe extern "C" {
    pub fn wl_proxy_destroy(proxy: *mut wl_proxy);
}
unsafe extern "C" {
    pub fn wl_proxy_add_listener(
        proxy: *mut wl_proxy,
        implementation: *mut ::core::option::Option<unsafe extern "C" fn()>,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_proxy_get_listener(proxy: *mut wl_proxy) -> *const ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn wl_proxy_add_dispatcher(
        proxy: *mut wl_proxy,
        dispatcher_func: wl_dispatcher_func_t,
        dispatcher_data: *const ::core::ffi::c_void,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_proxy_set_user_data(proxy: *mut wl_proxy, user_data: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    pub fn wl_proxy_get_user_data(proxy: *mut wl_proxy) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn wl_proxy_get_version(proxy: *mut wl_proxy) -> u32;
}
unsafe extern "C" {
    pub fn wl_proxy_get_id(proxy: *mut wl_proxy) -> u32;
}
unsafe extern "C" {
    pub fn wl_proxy_set_tag(proxy: *mut wl_proxy, tag: *const *const ::core::ffi::c_char);
}
unsafe extern "C" {
    pub fn wl_proxy_get_tag(proxy: *mut wl_proxy) -> *const *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn wl_proxy_get_class(proxy: *mut wl_proxy) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn wl_proxy_get_display(proxy: *mut wl_proxy) -> *mut wl_display;
}
unsafe extern "C" {
    pub fn wl_proxy_set_queue(proxy: *mut wl_proxy, queue: *mut wl_event_queue);
}
unsafe extern "C" {
    pub fn wl_proxy_get_queue(proxy: *const wl_proxy) -> *mut wl_event_queue;
}
unsafe extern "C" {
    pub fn wl_event_queue_get_name(queue: *const wl_event_queue) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn wl_display_connect(name: *const ::core::ffi::c_char) -> *mut wl_display;
}
unsafe extern "C" {
    pub fn wl_display_connect_to_fd(fd: ::core::ffi::c_int) -> *mut wl_display;
}
unsafe extern "C" {
    pub fn wl_display_disconnect(display: *mut wl_display);
}
unsafe extern "C" {
    pub fn wl_display_get_fd(display: *mut wl_display) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_display_dispatch(display: *mut wl_display) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_display_dispatch_queue(
        display: *mut wl_display,
        queue: *mut wl_event_queue,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_display_dispatch_queue_pending(
        display: *mut wl_display,
        queue: *mut wl_event_queue,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_display_dispatch_pending(display: *mut wl_display) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_display_get_error(display: *mut wl_display) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_display_get_protocol_error(
        display: *mut wl_display,
        interface: *mut *const wl_interface,
        id: *mut u32,
    ) -> u32;
}
unsafe extern "C" {
    pub fn wl_display_flush(display: *mut wl_display) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_display_roundtrip_queue(
        display: *mut wl_display,
        queue: *mut wl_event_queue,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_display_roundtrip(display: *mut wl_display) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_display_create_queue(display: *mut wl_display) -> *mut wl_event_queue;
}
unsafe extern "C" {
    pub fn wl_display_create_queue_with_name(
        display: *mut wl_display,
        name: *const ::core::ffi::c_char,
    ) -> *mut wl_event_queue;
}
unsafe extern "C" {
    pub fn wl_display_prepare_read_queue(
        display: *mut wl_display,
        queue: *mut wl_event_queue,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_display_prepare_read(display: *mut wl_display) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_display_cancel_read(display: *mut wl_display);
}
unsafe extern "C" {
    pub fn wl_display_read_events(display: *mut wl_display) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_log_set_handler_client(handler: wl_log_func_t);
}
unsafe extern "C" {
    pub fn wl_display_set_max_buffer_size(display: *mut wl_display, max_buffer_size: usize);
}
#[doc = " @page page_wayland The wayland protocol\n @section page_ifaces_wayland Interfaces\n - @subpage page_iface_wl_display - core global object\n - @subpage page_iface_wl_registry - global registry object\n - @subpage page_iface_wl_callback - callback object\n - @subpage page_iface_wl_compositor - the compositor singleton\n - @subpage page_iface_wl_shm_pool - a shared memory pool\n - @subpage page_iface_wl_shm - shared memory support\n - @subpage page_iface_wl_buffer - content for a wl_surface\n - @subpage page_iface_wl_data_offer - offer to transfer data\n - @subpage page_iface_wl_data_source - offer to transfer data\n - @subpage page_iface_wl_data_device - data transfer device\n - @subpage page_iface_wl_data_device_manager - data transfer interface\n - @subpage page_iface_wl_shell - create desktop-style surfaces\n - @subpage page_iface_wl_shell_surface - desktop-style metadata interface\n - @subpage page_iface_wl_surface - an onscreen surface\n - @subpage page_iface_wl_seat - group of input devices\n - @subpage page_iface_wl_pointer - pointer input device\n - @subpage page_iface_wl_keyboard - keyboard input device\n - @subpage page_iface_wl_touch - touchscreen input device\n - @subpage page_iface_wl_output - compositor output region\n - @subpage page_iface_wl_region - region interface\n - @subpage page_iface_wl_subcompositor - sub-surface compositing\n - @subpage page_iface_wl_subsurface - sub-surface interface to a wl_surface\n @section page_copyright_wayland Copyright\n <pre>\n\n Copyright  2008-2011 Kristian Hgsberg\n Copyright  2010-2011 Intel Corporation\n Copyright  2012-2013 Collabora, Ltd.\n\n Permission is hereby granted, free of charge, to any person\n obtaining a copy of this software and associated documentation files\n (the \"Software\"), to deal in the Software without restriction,\n including without limitation the rights to use, copy, modify, merge,\n publish, distribute, sublicense, and/or sell copies of the Software,\n and to permit persons to whom the Software is furnished to do so,\n subject to the following conditions:\n\n The above copyright notice and this permission notice (including the\n next paragraph) shall be included in all copies or substantial\n portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n </pre>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_compositor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device_manager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_offer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_keyboard {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_output {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_pointer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_region {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_registry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_seat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_pool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_subcompositor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_subsurface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_touch {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_display wl_display\n @section page_iface_wl_display_desc Description\n\n The core global object.  This is a special singleton object.  It\n is used for internal Wayland protocol features.\n @section page_iface_wl_display_api API\n See @ref iface_wl_display.\n/\n/**\n @defgroup iface_wl_display The wl_display interface\n\n The core global object.  This is a special singleton object.  It\n is used for internal Wayland protocol features."]
    pub static wl_display_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_registry wl_registry\n @section page_iface_wl_registry_desc Description\n\n The singleton global registry object.  The server has a number of\n global objects that are available to all clients.  These objects\n typically represent an actual object in the server (for example,\n an input device) or they are singleton objects that provide\n extension functionality.\n\n When a client creates a registry object, the registry object\n will emit a global event for each global currently in the\n registry.  Globals come and go as a result of device or\n monitor hotplugs, reconfiguration or other events, and the\n registry will send out global and global_remove events to\n keep the client up to date with the changes.  To mark the end\n of the initial burst of events, the client can use the\n wl_display.sync request immediately after calling\n wl_display.get_registry.\n\n A client can bind to a global object by using the bind\n request.  This creates a client-side handle that lets the object\n emit events to the client and lets the client invoke requests on\n the object.\n @section page_iface_wl_registry_api API\n See @ref iface_wl_registry.\n/\n/**\n @defgroup iface_wl_registry The wl_registry interface\n\n The singleton global registry object.  The server has a number of\n global objects that are available to all clients.  These objects\n typically represent an actual object in the server (for example,\n an input device) or they are singleton objects that provide\n extension functionality.\n\n When a client creates a registry object, the registry object\n will emit a global event for each global currently in the\n registry.  Globals come and go as a result of device or\n monitor hotplugs, reconfiguration or other events, and the\n registry will send out global and global_remove events to\n keep the client up to date with the changes.  To mark the end\n of the initial burst of events, the client can use the\n wl_display.sync request immediately after calling\n wl_display.get_registry.\n\n A client can bind to a global object by using the bind\n request.  This creates a client-side handle that lets the object\n emit events to the client and lets the client invoke requests on\n the object."]
    pub static wl_registry_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_callback wl_callback\n @section page_iface_wl_callback_desc Description\n\n Clients can handle the 'done' event to get notified when\n the related request is done.\n\n Note, because wl_callback objects are created from multiple independent\n factory interfaces, the wl_callback interface is frozen at version 1.\n @section page_iface_wl_callback_api API\n See @ref iface_wl_callback.\n/\n/**\n @defgroup iface_wl_callback The wl_callback interface\n\n Clients can handle the 'done' event to get notified when\n the related request is done.\n\n Note, because wl_callback objects are created from multiple independent\n factory interfaces, the wl_callback interface is frozen at version 1."]
    pub static wl_callback_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_compositor wl_compositor\n @section page_iface_wl_compositor_desc Description\n\n A compositor.  This object is a singleton global.  The\n compositor is in charge of combining the contents of multiple\n surfaces into one displayable output.\n @section page_iface_wl_compositor_api API\n See @ref iface_wl_compositor.\n/\n/**\n @defgroup iface_wl_compositor The wl_compositor interface\n\n A compositor.  This object is a singleton global.  The\n compositor is in charge of combining the contents of multiple\n surfaces into one displayable output."]
    pub static wl_compositor_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_shm_pool wl_shm_pool\n @section page_iface_wl_shm_pool_desc Description\n\n The wl_shm_pool object encapsulates a piece of memory shared\n between the compositor and client.  Through the wl_shm_pool\n object, the client can allocate shared memory wl_buffer objects.\n All objects created through the same pool share the same\n underlying mapped memory. Reusing the mapped memory avoids the\n setup/teardown overhead and is useful when interactively resizing\n a surface or for many small buffers.\n @section page_iface_wl_shm_pool_api API\n See @ref iface_wl_shm_pool.\n/\n/**\n @defgroup iface_wl_shm_pool The wl_shm_pool interface\n\n The wl_shm_pool object encapsulates a piece of memory shared\n between the compositor and client.  Through the wl_shm_pool\n object, the client can allocate shared memory wl_buffer objects.\n All objects created through the same pool share the same\n underlying mapped memory. Reusing the mapped memory avoids the\n setup/teardown overhead and is useful when interactively resizing\n a surface or for many small buffers."]
    pub static wl_shm_pool_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_shm wl_shm\n @section page_iface_wl_shm_desc Description\n\n A singleton global object that provides support for shared\n memory.\n\n Clients can create wl_shm_pool objects using the create_pool\n request.\n\n On binding the wl_shm object one or more format events\n are emitted to inform clients about the valid pixel formats\n that can be used for buffers.\n @section page_iface_wl_shm_api API\n See @ref iface_wl_shm.\n/\n/**\n @defgroup iface_wl_shm The wl_shm interface\n\n A singleton global object that provides support for shared\n memory.\n\n Clients can create wl_shm_pool objects using the create_pool\n request.\n\n On binding the wl_shm object one or more format events\n are emitted to inform clients about the valid pixel formats\n that can be used for buffers."]
    pub static wl_shm_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_buffer wl_buffer\n @section page_iface_wl_buffer_desc Description\n\n A buffer provides the content for a wl_surface. Buffers are\n created through factory interfaces such as wl_shm, wp_linux_buffer_params\n (from the linux-dmabuf protocol extension) or similar. It has a width and\n a height and can be attached to a wl_surface, but the mechanism by which a\n client provides and updates the contents is defined by the buffer factory\n interface.\n\n Color channels are assumed to be electrical rather than optical (in other\n words, encoded with a transfer function) unless otherwise specified. If\n the buffer uses a format that has an alpha channel, the alpha channel is\n assumed to be premultiplied into the electrical color channel values\n (after transfer function encoding) unless otherwise specified.\n\n Note, because wl_buffer objects are created from multiple independent\n factory interfaces, the wl_buffer interface is frozen at version 1.\n @section page_iface_wl_buffer_api API\n See @ref iface_wl_buffer.\n/\n/**\n @defgroup iface_wl_buffer The wl_buffer interface\n\n A buffer provides the content for a wl_surface. Buffers are\n created through factory interfaces such as wl_shm, wp_linux_buffer_params\n (from the linux-dmabuf protocol extension) or similar. It has a width and\n a height and can be attached to a wl_surface, but the mechanism by which a\n client provides and updates the contents is defined by the buffer factory\n interface.\n\n Color channels are assumed to be electrical rather than optical (in other\n words, encoded with a transfer function) unless otherwise specified. If\n the buffer uses a format that has an alpha channel, the alpha channel is\n assumed to be premultiplied into the electrical color channel values\n (after transfer function encoding) unless otherwise specified.\n\n Note, because wl_buffer objects are created from multiple independent\n factory interfaces, the wl_buffer interface is frozen at version 1."]
    pub static wl_buffer_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_data_offer wl_data_offer\n @section page_iface_wl_data_offer_desc Description\n\n A wl_data_offer represents a piece of data offered for transfer\n by another client (the source client).  It is used by the\n copy-and-paste and drag-and-drop mechanisms.  The offer\n describes the different mime types that the data can be\n converted to and provides the mechanism for transferring the\n data directly from the source client.\n @section page_iface_wl_data_offer_api API\n See @ref iface_wl_data_offer.\n/\n/**\n @defgroup iface_wl_data_offer The wl_data_offer interface\n\n A wl_data_offer represents a piece of data offered for transfer\n by another client (the source client).  It is used by the\n copy-and-paste and drag-and-drop mechanisms.  The offer\n describes the different mime types that the data can be\n converted to and provides the mechanism for transferring the\n data directly from the source client."]
    pub static wl_data_offer_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_data_source wl_data_source\n @section page_iface_wl_data_source_desc Description\n\n The wl_data_source object is the source side of a wl_data_offer.\n It is created by the source client in a data transfer and\n provides a way to describe the offered data and a way to respond\n to requests to transfer the data.\n @section page_iface_wl_data_source_api API\n See @ref iface_wl_data_source.\n/\n/**\n @defgroup iface_wl_data_source The wl_data_source interface\n\n The wl_data_source object is the source side of a wl_data_offer.\n It is created by the source client in a data transfer and\n provides a way to describe the offered data and a way to respond\n to requests to transfer the data."]
    pub static wl_data_source_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_data_device wl_data_device\n @section page_iface_wl_data_device_desc Description\n\n There is one wl_data_device per seat which can be obtained\n from the global wl_data_device_manager singleton.\n\n A wl_data_device provides access to inter-client data transfer\n mechanisms such as copy-and-paste and drag-and-drop.\n @section page_iface_wl_data_device_api API\n See @ref iface_wl_data_device.\n/\n/**\n @defgroup iface_wl_data_device The wl_data_device interface\n\n There is one wl_data_device per seat which can be obtained\n from the global wl_data_device_manager singleton.\n\n A wl_data_device provides access to inter-client data transfer\n mechanisms such as copy-and-paste and drag-and-drop."]
    pub static wl_data_device_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_data_device_manager wl_data_device_manager\n @section page_iface_wl_data_device_manager_desc Description\n\n The wl_data_device_manager is a singleton global object that\n provides access to inter-client data transfer mechanisms such as\n copy-and-paste and drag-and-drop.  These mechanisms are tied to\n a wl_seat and this interface lets a client get a wl_data_device\n corresponding to a wl_seat.\n\n Depending on the version bound, the objects created from the bound\n wl_data_device_manager object will have different requirements for\n functioning properly. See wl_data_source.set_actions,\n wl_data_offer.accept and wl_data_offer.finish for details.\n @section page_iface_wl_data_device_manager_api API\n See @ref iface_wl_data_device_manager.\n/\n/**\n @defgroup iface_wl_data_device_manager The wl_data_device_manager interface\n\n The wl_data_device_manager is a singleton global object that\n provides access to inter-client data transfer mechanisms such as\n copy-and-paste and drag-and-drop.  These mechanisms are tied to\n a wl_seat and this interface lets a client get a wl_data_device\n corresponding to a wl_seat.\n\n Depending on the version bound, the objects created from the bound\n wl_data_device_manager object will have different requirements for\n functioning properly. See wl_data_source.set_actions,\n wl_data_offer.accept and wl_data_offer.finish for details."]
    pub static wl_data_device_manager_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_shell wl_shell\n @section page_iface_wl_shell_desc Description\n\n This interface is implemented by servers that provide\n desktop-style user interfaces.\n\n It allows clients to associate a wl_shell_surface with\n a basic surface.\n\n Note! This protocol is deprecated and not intended for production use.\n For desktop-style user interfaces, use xdg_shell. Compositors and clients\n should not implement this interface.\n @section page_iface_wl_shell_api API\n See @ref iface_wl_shell.\n/\n/**\n @defgroup iface_wl_shell The wl_shell interface\n\n This interface is implemented by servers that provide\n desktop-style user interfaces.\n\n It allows clients to associate a wl_shell_surface with\n a basic surface.\n\n Note! This protocol is deprecated and not intended for production use.\n For desktop-style user interfaces, use xdg_shell. Compositors and clients\n should not implement this interface."]
    pub static wl_shell_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_shell_surface wl_shell_surface\n @section page_iface_wl_shell_surface_desc Description\n\n An interface that may be implemented by a wl_surface, for\n implementations that provide a desktop-style user interface.\n\n It provides requests to treat surfaces like toplevel, fullscreen\n or popup windows, move, resize or maximize them, associate\n metadata like title and class, etc.\n\n On the server side the object is automatically destroyed when\n the related wl_surface is destroyed. On the client side,\n wl_shell_surface_destroy() must be called before destroying\n the wl_surface object.\n @section page_iface_wl_shell_surface_api API\n See @ref iface_wl_shell_surface.\n/\n/**\n @defgroup iface_wl_shell_surface The wl_shell_surface interface\n\n An interface that may be implemented by a wl_surface, for\n implementations that provide a desktop-style user interface.\n\n It provides requests to treat surfaces like toplevel, fullscreen\n or popup windows, move, resize or maximize them, associate\n metadata like title and class, etc.\n\n On the server side the object is automatically destroyed when\n the related wl_surface is destroyed. On the client side,\n wl_shell_surface_destroy() must be called before destroying\n the wl_surface object."]
    pub static wl_shell_surface_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_surface wl_surface\n @section page_iface_wl_surface_desc Description\n\n A surface is a rectangular area that may be displayed on zero\n or more outputs, and shown any number of times at the compositor's\n discretion. They can present wl_buffers, receive user input, and\n define a local coordinate system.\n\n The size of a surface (and relative positions on it) is described\n in surface-local coordinates, which may differ from the buffer\n coordinates of the pixel content, in case a buffer_transform\n or a buffer_scale is used.\n\n A surface without a \"role\" is fairly useless: a compositor does\n not know where, when or how to present it. The role is the\n purpose of a wl_surface. Examples of roles are a cursor for a\n pointer (as set by wl_pointer.set_cursor), a drag icon\n (wl_data_device.start_drag), a sub-surface\n (wl_subcompositor.get_subsurface), and a window as defined by a\n shell protocol (e.g. wl_shell.get_shell_surface).\n\n A surface can have only one role at a time. Initially a\n wl_surface does not have a role. Once a wl_surface is given a\n role, it is set permanently for the whole lifetime of the\n wl_surface object. Giving the current role again is allowed,\n unless explicitly forbidden by the relevant interface\n specification.\n\n Surface roles are given by requests in other interfaces such as\n wl_pointer.set_cursor. The request should explicitly mention\n that this request gives a role to a wl_surface. Often, this\n request also creates a new protocol object that represents the\n role and adds additional functionality to wl_surface. When a\n client wants to destroy a wl_surface, they must destroy this role\n object before the wl_surface, otherwise a defunct_role_object error is\n sent.\n\n Destroying the role object does not remove the role from the\n wl_surface, but it may stop the wl_surface from \"playing the role\".\n For instance, if a wl_subsurface object is destroyed, the wl_surface\n it was created for will be unmapped and forget its position and\n z-order. It is allowed to create a wl_subsurface for the same\n wl_surface again, but it is not allowed to use the wl_surface as\n a cursor (cursor is a different role than sub-surface, and role\n switching is not allowed).\n @section page_iface_wl_surface_api API\n See @ref iface_wl_surface.\n/\n/**\n @defgroup iface_wl_surface The wl_surface interface\n\n A surface is a rectangular area that may be displayed on zero\n or more outputs, and shown any number of times at the compositor's\n discretion. They can present wl_buffers, receive user input, and\n define a local coordinate system.\n\n The size of a surface (and relative positions on it) is described\n in surface-local coordinates, which may differ from the buffer\n coordinates of the pixel content, in case a buffer_transform\n or a buffer_scale is used.\n\n A surface without a \"role\" is fairly useless: a compositor does\n not know where, when or how to present it. The role is the\n purpose of a wl_surface. Examples of roles are a cursor for a\n pointer (as set by wl_pointer.set_cursor), a drag icon\n (wl_data_device.start_drag), a sub-surface\n (wl_subcompositor.get_subsurface), and a window as defined by a\n shell protocol (e.g. wl_shell.get_shell_surface).\n\n A surface can have only one role at a time. Initially a\n wl_surface does not have a role. Once a wl_surface is given a\n role, it is set permanently for the whole lifetime of the\n wl_surface object. Giving the current role again is allowed,\n unless explicitly forbidden by the relevant interface\n specification.\n\n Surface roles are given by requests in other interfaces such as\n wl_pointer.set_cursor. The request should explicitly mention\n that this request gives a role to a wl_surface. Often, this\n request also creates a new protocol object that represents the\n role and adds additional functionality to wl_surface. When a\n client wants to destroy a wl_surface, they must destroy this role\n object before the wl_surface, otherwise a defunct_role_object error is\n sent.\n\n Destroying the role object does not remove the role from the\n wl_surface, but it may stop the wl_surface from \"playing the role\".\n For instance, if a wl_subsurface object is destroyed, the wl_surface\n it was created for will be unmapped and forget its position and\n z-order. It is allowed to create a wl_subsurface for the same\n wl_surface again, but it is not allowed to use the wl_surface as\n a cursor (cursor is a different role than sub-surface, and role\n switching is not allowed)."]
    pub static wl_surface_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_seat wl_seat\n @section page_iface_wl_seat_desc Description\n\n A seat is a group of keyboards, pointer and touch devices. This\n object is published as a global during start up, or when such a\n device is hot plugged.  A seat typically has a pointer and\n maintains a keyboard focus and a pointer focus.\n @section page_iface_wl_seat_api API\n See @ref iface_wl_seat.\n/\n/**\n @defgroup iface_wl_seat The wl_seat interface\n\n A seat is a group of keyboards, pointer and touch devices. This\n object is published as a global during start up, or when such a\n device is hot plugged.  A seat typically has a pointer and\n maintains a keyboard focus and a pointer focus."]
    pub static wl_seat_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_pointer wl_pointer\n @section page_iface_wl_pointer_desc Description\n\n The wl_pointer interface represents one or more input devices,\n such as mice, which control the pointer location and pointer_focus\n of a seat.\n\n The wl_pointer interface generates motion, enter and leave\n events for the surfaces that the pointer is located over,\n and button and axis events for button presses, button releases\n and scrolling.\n @section page_iface_wl_pointer_api API\n See @ref iface_wl_pointer.\n/\n/**\n @defgroup iface_wl_pointer The wl_pointer interface\n\n The wl_pointer interface represents one or more input devices,\n such as mice, which control the pointer location and pointer_focus\n of a seat.\n\n The wl_pointer interface generates motion, enter and leave\n events for the surfaces that the pointer is located over,\n and button and axis events for button presses, button releases\n and scrolling."]
    pub static wl_pointer_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_keyboard wl_keyboard\n @section page_iface_wl_keyboard_desc Description\n\n The wl_keyboard interface represents one or more keyboards\n associated with a seat.\n\n Each wl_keyboard has the following logical state:\n\n - an active surface (possibly null),\n - the keys currently logically down,\n - the active modifiers,\n - the active group.\n\n By default, the active surface is null, the keys currently logically down\n are empty, the active modifiers and the active group are 0.\n @section page_iface_wl_keyboard_api API\n See @ref iface_wl_keyboard.\n/\n/**\n @defgroup iface_wl_keyboard The wl_keyboard interface\n\n The wl_keyboard interface represents one or more keyboards\n associated with a seat.\n\n Each wl_keyboard has the following logical state:\n\n - an active surface (possibly null),\n - the keys currently logically down,\n - the active modifiers,\n - the active group.\n\n By default, the active surface is null, the keys currently logically down\n are empty, the active modifiers and the active group are 0."]
    pub static wl_keyboard_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_touch wl_touch\n @section page_iface_wl_touch_desc Description\n\n The wl_touch interface represents a touchscreen\n associated with a seat.\n\n Touch interactions can consist of one or more contacts.\n For each contact, a series of events is generated, starting\n with a down event, followed by zero or more motion events,\n and ending with an up event. Events relating to the same\n contact point can be identified by the ID of the sequence.\n @section page_iface_wl_touch_api API\n See @ref iface_wl_touch.\n/\n/**\n @defgroup iface_wl_touch The wl_touch interface\n\n The wl_touch interface represents a touchscreen\n associated with a seat.\n\n Touch interactions can consist of one or more contacts.\n For each contact, a series of events is generated, starting\n with a down event, followed by zero or more motion events,\n and ending with an up event. Events relating to the same\n contact point can be identified by the ID of the sequence."]
    pub static wl_touch_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_output wl_output\n @section page_iface_wl_output_desc Description\n\n An output describes part of the compositor geometry.  The\n compositor works in the 'compositor coordinate system' and an\n output corresponds to a rectangular area in that space that is\n actually visible.  This typically corresponds to a monitor that\n displays part of the compositor space.  This object is published\n as global during start up, or when a monitor is hotplugged.\n @section page_iface_wl_output_api API\n See @ref iface_wl_output.\n/\n/**\n @defgroup iface_wl_output The wl_output interface\n\n An output describes part of the compositor geometry.  The\n compositor works in the 'compositor coordinate system' and an\n output corresponds to a rectangular area in that space that is\n actually visible.  This typically corresponds to a monitor that\n displays part of the compositor space.  This object is published\n as global during start up, or when a monitor is hotplugged."]
    pub static wl_output_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_region wl_region\n @section page_iface_wl_region_desc Description\n\n A region object describes an area.\n\n Region objects are used to describe the opaque and input\n regions of a surface.\n @section page_iface_wl_region_api API\n See @ref iface_wl_region.\n/\n/**\n @defgroup iface_wl_region The wl_region interface\n\n A region object describes an area.\n\n Region objects are used to describe the opaque and input\n regions of a surface."]
    pub static wl_region_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_subcompositor wl_subcompositor\n @section page_iface_wl_subcompositor_desc Description\n\n The global interface exposing sub-surface compositing capabilities.\n A wl_surface, that has sub-surfaces associated, is called the\n parent surface. Sub-surfaces can be arbitrarily nested and create\n a tree of sub-surfaces.\n\n The root surface in a tree of sub-surfaces is the main\n surface. The main surface cannot be a sub-surface, because\n sub-surfaces must always have a parent.\n\n A main surface with its sub-surfaces forms a (compound) window.\n For window management purposes, this set of wl_surface objects is\n to be considered as a single window, and it should also behave as\n such.\n\n The aim of sub-surfaces is to offload some of the compositing work\n within a window from clients to the compositor. A prime example is\n a video player with decorations and video in separate wl_surface\n objects. This should allow the compositor to pass YUV video buffer\n processing to dedicated overlay hardware when possible.\n @section page_iface_wl_subcompositor_api API\n See @ref iface_wl_subcompositor.\n/\n/**\n @defgroup iface_wl_subcompositor The wl_subcompositor interface\n\n The global interface exposing sub-surface compositing capabilities.\n A wl_surface, that has sub-surfaces associated, is called the\n parent surface. Sub-surfaces can be arbitrarily nested and create\n a tree of sub-surfaces.\n\n The root surface in a tree of sub-surfaces is the main\n surface. The main surface cannot be a sub-surface, because\n sub-surfaces must always have a parent.\n\n A main surface with its sub-surfaces forms a (compound) window.\n For window management purposes, this set of wl_surface objects is\n to be considered as a single window, and it should also behave as\n such.\n\n The aim of sub-surfaces is to offload some of the compositing work\n within a window from clients to the compositor. A prime example is\n a video player with decorations and video in separate wl_surface\n objects. This should allow the compositor to pass YUV video buffer\n processing to dedicated overlay hardware when possible."]
    pub static wl_subcompositor_interface: wl_interface;
}
unsafe extern "C" {
    #[doc = " @page page_iface_wl_subsurface wl_subsurface\n @section page_iface_wl_subsurface_desc Description\n\n An additional interface to a wl_surface object, which has been\n made a sub-surface. A sub-surface has one parent surface. A\n sub-surface's size and position are not limited to that of the parent.\n Particularly, a sub-surface is not automatically clipped to its\n parent's area.\n\n A sub-surface becomes mapped, when a non-NULL wl_buffer is applied\n and the parent surface is mapped. The order of which one happens\n first is irrelevant. A sub-surface is hidden if the parent becomes\n hidden, or if a NULL wl_buffer is applied. These rules apply\n recursively through the tree of surfaces.\n\n The behaviour of a wl_surface.commit request on a sub-surface\n depends on the sub-surface's mode. The possible modes are\n synchronized and desynchronized, see methods\n wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized\n mode caches the wl_surface state to be applied when the parent's\n state gets applied, and desynchronized mode applies the pending\n wl_surface state directly. A sub-surface is initially in the\n synchronized mode.\n\n Sub-surfaces also have another kind of state, which is managed by\n wl_subsurface requests, as opposed to wl_surface requests. This\n state includes the sub-surface position relative to the parent\n surface (wl_subsurface.set_position), and the stacking order of\n the parent and its sub-surfaces (wl_subsurface.place_above and\n .place_below). This state is applied when the parent surface's\n wl_surface state is applied, regardless of the sub-surface's mode.\n As the exception, set_sync and set_desync are effective immediately.\n\n The main surface can be thought to be always in desynchronized mode,\n since it does not have a parent in the sub-surfaces sense.\n\n Even if a sub-surface is in desynchronized mode, it will behave as\n in synchronized mode, if its parent surface behaves as in\n synchronized mode. This rule is applied recursively throughout the\n tree of surfaces. This means, that one can set a sub-surface into\n synchronized mode, and then assume that all its child and grand-child\n sub-surfaces are synchronized, too, without explicitly setting them.\n\n Destroying a sub-surface takes effect immediately. If you need to\n synchronize the removal of a sub-surface to the parent surface update,\n unmap the sub-surface first by attaching a NULL wl_buffer, update parent,\n and then destroy the sub-surface.\n\n If the parent wl_surface object is destroyed, the sub-surface is\n unmapped.\n\n A sub-surface never has the keyboard focus of any seat.\n\n The wl_surface.offset request is ignored: clients must use set_position\n instead to move the sub-surface.\n @section page_iface_wl_subsurface_api API\n See @ref iface_wl_subsurface.\n/\n/**\n @defgroup iface_wl_subsurface The wl_subsurface interface\n\n An additional interface to a wl_surface object, which has been\n made a sub-surface. A sub-surface has one parent surface. A\n sub-surface's size and position are not limited to that of the parent.\n Particularly, a sub-surface is not automatically clipped to its\n parent's area.\n\n A sub-surface becomes mapped, when a non-NULL wl_buffer is applied\n and the parent surface is mapped. The order of which one happens\n first is irrelevant. A sub-surface is hidden if the parent becomes\n hidden, or if a NULL wl_buffer is applied. These rules apply\n recursively through the tree of surfaces.\n\n The behaviour of a wl_surface.commit request on a sub-surface\n depends on the sub-surface's mode. The possible modes are\n synchronized and desynchronized, see methods\n wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized\n mode caches the wl_surface state to be applied when the parent's\n state gets applied, and desynchronized mode applies the pending\n wl_surface state directly. A sub-surface is initially in the\n synchronized mode.\n\n Sub-surfaces also have another kind of state, which is managed by\n wl_subsurface requests, as opposed to wl_surface requests. This\n state includes the sub-surface position relative to the parent\n surface (wl_subsurface.set_position), and the stacking order of\n the parent and its sub-surfaces (wl_subsurface.place_above and\n .place_below). This state is applied when the parent surface's\n wl_surface state is applied, regardless of the sub-surface's mode.\n As the exception, set_sync and set_desync are effective immediately.\n\n The main surface can be thought to be always in desynchronized mode,\n since it does not have a parent in the sub-surfaces sense.\n\n Even if a sub-surface is in desynchronized mode, it will behave as\n in synchronized mode, if its parent surface behaves as in\n synchronized mode. This rule is applied recursively throughout the\n tree of surfaces. This means, that one can set a sub-surface into\n synchronized mode, and then assume that all its child and grand-child\n sub-surfaces are synchronized, too, without explicitly setting them.\n\n Destroying a sub-surface takes effect immediately. If you need to\n synchronize the removal of a sub-surface to the parent surface update,\n unmap the sub-surface first by attaching a NULL wl_buffer, update parent,\n and then destroy the sub-surface.\n\n If the parent wl_surface object is destroyed, the sub-surface is\n unmapped.\n\n A sub-surface never has the keyboard focus of any seat.\n\n The wl_surface.offset request is ignored: clients must use set_position\n instead to move the sub-surface."]
    pub static wl_subsurface_interface: wl_interface;
}
#[doc = " server couldn't find object"]
pub const wl_display_error_WL_DISPLAY_ERROR_INVALID_OBJECT: wl_display_error = 0;
#[doc = " method doesn't exist on the specified interface or malformed request"]
pub const wl_display_error_WL_DISPLAY_ERROR_INVALID_METHOD: wl_display_error = 1;
#[doc = " server is out of memory"]
pub const wl_display_error_WL_DISPLAY_ERROR_NO_MEMORY: wl_display_error = 2;
#[doc = " implementation error in compositor"]
pub const wl_display_error_WL_DISPLAY_ERROR_IMPLEMENTATION: wl_display_error = 3;
#[doc = " @ingroup iface_wl_display\n global error values\n\n These errors are global and can be emitted in response to any\n server request."]
pub type wl_display_error = ::core::ffi::c_uint;
#[doc = " @ingroup iface_wl_display\n @struct wl_display_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_display_listener {
    #[doc = " fatal error event\n\n The error event is sent out when a fatal (non-recoverable)\n error has occurred. The object_id argument is the object where\n the error occurred, most often in response to a request to that\n object. The code identifies the error and is defined by the\n object interface. As such, each interface defines its own set of\n error codes. The message is a brief description of the error,\n for (debugging) convenience.\n @param object_id object where the error occurred\n @param code error code\n @param message error description"]
    pub error: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_display: *mut wl_display,
            object_id: *mut ::core::ffi::c_void,
            code: u32,
            message: *const ::core::ffi::c_char,
        ),
    >,
    #[doc = " acknowledge object ID deletion\n\n This event is used internally by the object ID management\n logic. When a client deletes an object that it had created, the\n server will send this event to acknowledge that it has seen the\n delete request. When the client receives this event, it will\n know that it can safely reuse the object ID.\n @param id deleted object ID"]
    pub delete_id: ::core::option::Option<
        unsafe extern "C" fn(data: *mut ::core::ffi::c_void, wl_display: *mut wl_display, id: u32),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_display_listener"][::core::mem::size_of::<wl_display_listener>() - 16usize];
    ["Alignment of wl_display_listener"][::core::mem::align_of::<wl_display_listener>() - 8usize];
    ["Offset of field: wl_display_listener::error"]
        [::core::mem::offset_of!(wl_display_listener, error) - 0usize];
    ["Offset of field: wl_display_listener::delete_id"]
        [::core::mem::offset_of!(wl_display_listener, delete_id) - 8usize];
};
#[doc = " @ingroup iface_wl_registry\n @struct wl_registry_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_registry_listener {
    #[doc = " announce global object\n\n Notify the client of global objects.\n\n The event notifies the client that a global object with the\n given name is now available, and it implements the given version\n of the given interface.\n @param name numeric name of the global object\n @param interface interface implemented by the object\n @param version interface version"]
    pub global: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_registry: *mut wl_registry,
            name: u32,
            interface: *const ::core::ffi::c_char,
            version: u32,
        ),
    >,
    #[doc = " announce removal of global object\n\n Notify the client of removed global objects.\n\n This event notifies the client that the global identified by\n name is no longer available. If the client bound to the global\n using the bind request, the client should now destroy that\n object.\n\n The object remains valid and requests to the object will be\n ignored until the client destroys it, to avoid races between the\n global going away and a client sending a request to it.\n @param name numeric name of the global object"]
    pub global_remove: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_registry: *mut wl_registry,
            name: u32,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_registry_listener"][::core::mem::size_of::<wl_registry_listener>() - 16usize];
    ["Alignment of wl_registry_listener"][::core::mem::align_of::<wl_registry_listener>() - 8usize];
    ["Offset of field: wl_registry_listener::global"]
        [::core::mem::offset_of!(wl_registry_listener, global) - 0usize];
    ["Offset of field: wl_registry_listener::global_remove"]
        [::core::mem::offset_of!(wl_registry_listener, global_remove) - 8usize];
};
#[doc = " @ingroup iface_wl_callback\n @struct wl_callback_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_callback_listener {
    #[doc = " done event\n\n Notify the client when the related request is done.\n @param callback_data request-specific data for the callback"]
    pub done: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_callback: *mut wl_callback,
            callback_data: u32,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_callback_listener"][::core::mem::size_of::<wl_callback_listener>() - 8usize];
    ["Alignment of wl_callback_listener"][::core::mem::align_of::<wl_callback_listener>() - 8usize];
    ["Offset of field: wl_callback_listener::done"]
        [::core::mem::offset_of!(wl_callback_listener, done) - 0usize];
};
#[doc = " buffer format is not known"]
pub const wl_shm_error_WL_SHM_ERROR_INVALID_FORMAT: wl_shm_error = 0;
#[doc = " invalid size or stride during pool or buffer creation"]
pub const wl_shm_error_WL_SHM_ERROR_INVALID_STRIDE: wl_shm_error = 1;
#[doc = " mmapping the file descriptor failed"]
pub const wl_shm_error_WL_SHM_ERROR_INVALID_FD: wl_shm_error = 2;
#[doc = " @ingroup iface_wl_shm\n wl_shm error values\n\n These errors can be emitted in response to wl_shm requests."]
pub type wl_shm_error = ::core::ffi::c_uint;
#[doc = " 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB8888: wl_shm_format = 0;
#[doc = " 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB8888: wl_shm_format = 1;
#[doc = " 8-bit color index format, [7:0] C"]
pub const wl_shm_format_WL_SHM_FORMAT_C8: wl_shm_format = 538982467;
#[doc = " 8-bit RGB format, [7:0] R:G:B 3:3:2"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB332: wl_shm_format = 943867730;
#[doc = " 8-bit BGR format, [7:0] B:G:R 2:3:3"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR233: wl_shm_format = 944916290;
#[doc = " 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB4444: wl_shm_format = 842093144;
#[doc = " 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR4444: wl_shm_format = 842089048;
#[doc = " 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX4444: wl_shm_format = 842094674;
#[doc = " 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX4444: wl_shm_format = 842094658;
#[doc = " 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB4444: wl_shm_format = 842093121;
#[doc = " 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR4444: wl_shm_format = 842089025;
#[doc = " 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBA4444: wl_shm_format = 842088786;
#[doc = " 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRA4444: wl_shm_format = 842088770;
#[doc = " 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB1555: wl_shm_format = 892424792;
#[doc = " 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR1555: wl_shm_format = 892420696;
#[doc = " 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX5551: wl_shm_format = 892426322;
#[doc = " 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX5551: wl_shm_format = 892426306;
#[doc = " 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB1555: wl_shm_format = 892424769;
#[doc = " 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR1555: wl_shm_format = 892420673;
#[doc = " 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBA5551: wl_shm_format = 892420434;
#[doc = " 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRA5551: wl_shm_format = 892420418;
#[doc = " 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB565: wl_shm_format = 909199186;
#[doc = " 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR565: wl_shm_format = 909199170;
#[doc = " 24-bit RGB format, [23:0] R:G:B little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB888: wl_shm_format = 875710290;
#[doc = " 24-bit BGR format, [23:0] B:G:R little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR888: wl_shm_format = 875710274;
#[doc = " 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR8888: wl_shm_format = 875709016;
#[doc = " 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX8888: wl_shm_format = 875714642;
#[doc = " 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX8888: wl_shm_format = 875714626;
#[doc = " 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR8888: wl_shm_format = 875708993;
#[doc = " 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBA8888: wl_shm_format = 875708754;
#[doc = " 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRA8888: wl_shm_format = 875708738;
#[doc = " 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB2101010: wl_shm_format = 808669784;
#[doc = " 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR2101010: wl_shm_format = 808665688;
#[doc = " 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX1010102: wl_shm_format = 808671314;
#[doc = " 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX1010102: wl_shm_format = 808671298;
#[doc = " 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB2101010: wl_shm_format = 808669761;
#[doc = " 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR2101010: wl_shm_format = 808665665;
#[doc = " 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBA1010102: wl_shm_format = 808665426;
#[doc = " 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRA1010102: wl_shm_format = 808665410;
#[doc = " packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_YUYV: wl_shm_format = 1448695129;
#[doc = " packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_YVYU: wl_shm_format = 1431918169;
#[doc = " packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_UYVY: wl_shm_format = 1498831189;
#[doc = " packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_VYUY: wl_shm_format = 1498765654;
#[doc = " packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_AYUV: wl_shm_format = 1448433985;
#[doc = " 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV12: wl_shm_format = 842094158;
#[doc = " 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV21: wl_shm_format = 825382478;
#[doc = " 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV16: wl_shm_format = 909203022;
#[doc = " 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV61: wl_shm_format = 825644622;
#[doc = " 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV410: wl_shm_format = 961959257;
#[doc = " 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU410: wl_shm_format = 961893977;
#[doc = " 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV411: wl_shm_format = 825316697;
#[doc = " 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU411: wl_shm_format = 825316953;
#[doc = " 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV420: wl_shm_format = 842093913;
#[doc = " 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU420: wl_shm_format = 842094169;
#[doc = " 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV422: wl_shm_format = 909202777;
#[doc = " 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU422: wl_shm_format = 909203033;
#[doc = " 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV444: wl_shm_format = 875713881;
#[doc = " 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU444: wl_shm_format = 875714137;
#[doc = " [7:0] R"]
pub const wl_shm_format_WL_SHM_FORMAT_R8: wl_shm_format = 538982482;
#[doc = " [15:0] R little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_R16: wl_shm_format = 540422482;
#[doc = " [15:0] R:G 8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RG88: wl_shm_format = 943212370;
#[doc = " [15:0] G:R 8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_GR88: wl_shm_format = 943215175;
#[doc = " [31:0] R:G 16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RG1616: wl_shm_format = 842221394;
#[doc = " [31:0] G:R 16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_GR1616: wl_shm_format = 842224199;
#[doc = " [63:0] x:R:G:B 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB16161616F: wl_shm_format = 1211388504;
#[doc = " [63:0] x:B:G:R 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR16161616F: wl_shm_format = 1211384408;
#[doc = " [63:0] A:R:G:B 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB16161616F: wl_shm_format = 1211388481;
#[doc = " [63:0] A:B:G:R 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR16161616F: wl_shm_format = 1211384385;
#[doc = " [31:0] X:Y:Cb:Cr 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XYUV8888: wl_shm_format = 1448434008;
#[doc = " [23:0] Cr:Cb:Y 8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_VUY888: wl_shm_format = 875713878;
#[doc = " Y followed by U then V, 10:10:10. Non-linear modifier only"]
pub const wl_shm_format_WL_SHM_FORMAT_VUY101010: wl_shm_format = 808670550;
#[doc = " [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels"]
pub const wl_shm_format_WL_SHM_FORMAT_Y210: wl_shm_format = 808530521;
#[doc = " [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels"]
pub const wl_shm_format_WL_SHM_FORMAT_Y212: wl_shm_format = 842084953;
#[doc = " [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels"]
pub const wl_shm_format_WL_SHM_FORMAT_Y216: wl_shm_format = 909193817;
#[doc = " [31:0] A:Cr:Y:Cb 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y410: wl_shm_format = 808531033;
#[doc = " [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y412: wl_shm_format = 842085465;
#[doc = " [63:0] A:Cr:Y:Cb 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y416: wl_shm_format = 909194329;
#[doc = " [31:0] X:Cr:Y:Cb 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XVYU2101010: wl_shm_format = 808670808;
#[doc = " [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XVYU12_16161616: wl_shm_format = 909334104;
#[doc = " [63:0] X:Cr:Y:Cb 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XVYU16161616: wl_shm_format = 942954072;
#[doc = " [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y0L0: wl_shm_format = 810299481;
#[doc = " [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_X0L0: wl_shm_format = 810299480;
#[doc = " [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y0L2: wl_shm_format = 843853913;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_X0L2: wl_shm_format = 843853912;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV420_8BIT: wl_shm_format = 942691673;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV420_10BIT: wl_shm_format = 808539481;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB8888_A8: wl_shm_format = 943805016;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR8888_A8: wl_shm_format = 943800920;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX8888_A8: wl_shm_format = 943806546;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX8888_A8: wl_shm_format = 943806530;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB888_A8: wl_shm_format = 943798354;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR888_A8: wl_shm_format = 943798338;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB565_A8: wl_shm_format = 943797586;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR565_A8: wl_shm_format = 943797570;
#[doc = " non-subsampled Cr:Cb plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV24: wl_shm_format = 875714126;
#[doc = " non-subsampled Cb:Cr plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV42: wl_shm_format = 842290766;
#[doc = " 2x1 subsampled Cr:Cb plane, 10 bit per channel"]
pub const wl_shm_format_WL_SHM_FORMAT_P210: wl_shm_format = 808530512;
#[doc = " 2x2 subsampled Cr:Cb plane 10 bits per channel"]
pub const wl_shm_format_WL_SHM_FORMAT_P010: wl_shm_format = 808530000;
#[doc = " 2x2 subsampled Cr:Cb plane 12 bits per channel"]
pub const wl_shm_format_WL_SHM_FORMAT_P012: wl_shm_format = 842084432;
#[doc = " 2x2 subsampled Cr:Cb plane 16 bits per channel"]
pub const wl_shm_format_WL_SHM_FORMAT_P016: wl_shm_format = 909193296;
#[doc = " [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_AXBXGXRX106106106106: wl_shm_format = 808534593;
#[doc = " 2x2 subsampled Cr:Cb plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV15: wl_shm_format = 892425806;
#[doc = " 2x2 subsampled Cr:Cb plane"]
pub const wl_shm_format_WL_SHM_FORMAT_Q410: wl_shm_format = 808531025;
#[doc = " 2x2 subsampled Cr:Cb plane"]
pub const wl_shm_format_WL_SHM_FORMAT_Q401: wl_shm_format = 825242705;
#[doc = " [63:0] x:R:G:B 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB16161616: wl_shm_format = 942953048;
#[doc = " [63:0] x:B:G:R 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR16161616: wl_shm_format = 942948952;
#[doc = " [63:0] A:R:G:B 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB16161616: wl_shm_format = 942953025;
#[doc = " [63:0] A:B:G:R 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR16161616: wl_shm_format = 942948929;
#[doc = " [7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte"]
pub const wl_shm_format_WL_SHM_FORMAT_C1: wl_shm_format = 538980675;
#[doc = " [7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte"]
pub const wl_shm_format_WL_SHM_FORMAT_C2: wl_shm_format = 538980931;
#[doc = " [7:0] C0:C1 4:4 two pixels/byte"]
pub const wl_shm_format_WL_SHM_FORMAT_C4: wl_shm_format = 538981443;
#[doc = " [7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte"]
pub const wl_shm_format_WL_SHM_FORMAT_D1: wl_shm_format = 538980676;
#[doc = " [7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte"]
pub const wl_shm_format_WL_SHM_FORMAT_D2: wl_shm_format = 538980932;
#[doc = " [7:0] D0:D1 4:4 two pixels/byte"]
pub const wl_shm_format_WL_SHM_FORMAT_D4: wl_shm_format = 538981444;
#[doc = " [7:0] D"]
pub const wl_shm_format_WL_SHM_FORMAT_D8: wl_shm_format = 538982468;
#[doc = " [7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte"]
pub const wl_shm_format_WL_SHM_FORMAT_R1: wl_shm_format = 538980690;
#[doc = " [7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte"]
pub const wl_shm_format_WL_SHM_FORMAT_R2: wl_shm_format = 538980946;
#[doc = " [7:0] R0:R1 4:4 two pixels/byte"]
pub const wl_shm_format_WL_SHM_FORMAT_R4: wl_shm_format = 538981458;
#[doc = " [15:0] x:R 6:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_R10: wl_shm_format = 540029266;
#[doc = " [15:0] x:R 4:12 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_R12: wl_shm_format = 540160338;
#[doc = " [31:0] A:Cr:Cb:Y 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_AVUY8888: wl_shm_format = 1498764865;
#[doc = " [31:0] X:Cr:Cb:Y 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XVUY8888: wl_shm_format = 1498764888;
#[doc = " 2x2 subsampled Cr:Cb plane 10 bits per channel packed"]
pub const wl_shm_format_WL_SHM_FORMAT_P030: wl_shm_format = 808661072;
#[doc = " @ingroup iface_wl_shm\n pixel formats\n\n This describes the memory layout of an individual pixel.\n\n All renderers should support argb8888 and xrgb8888 but any other\n formats are optional and may not be supported by the particular\n renderer in use.\n\n The drm format codes match the macros defined in drm_fourcc.h, except\n argb8888 and xrgb8888. The formats actually supported by the compositor\n will be reported by the format event.\n\n For all wl_shm formats and unless specified in another protocol\n extension, pre-multiplied alpha is used for pixel values."]
pub type wl_shm_format = ::core::ffi::c_uint;
#[doc = " @ingroup iface_wl_shm\n @struct wl_shm_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_listener {
    #[doc = " pixel format description\n\n Informs the client about a valid pixel format that can be used\n for buffers. Known formats include argb8888 and xrgb8888.\n @param format buffer pixel format"]
    pub format: ::core::option::Option<
        unsafe extern "C" fn(data: *mut ::core::ffi::c_void, wl_shm: *mut wl_shm, format: u32),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_shm_listener"][::core::mem::size_of::<wl_shm_listener>() - 8usize];
    ["Alignment of wl_shm_listener"][::core::mem::align_of::<wl_shm_listener>() - 8usize];
    ["Offset of field: wl_shm_listener::format"]
        [::core::mem::offset_of!(wl_shm_listener, format) - 0usize];
};
#[doc = " @ingroup iface_wl_buffer\n @struct wl_buffer_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_buffer_listener {
    #[doc = " compositor releases buffer\n\n Sent when this wl_buffer is no longer used by the compositor.\n The client is now free to reuse or destroy this buffer and its\n backing storage.\n\n If a client receives a release event before the frame callback\n requested in the same wl_surface.commit that attaches this\n wl_buffer to a surface, then the client is immediately free to\n reuse the buffer and its backing storage, and does not need a\n second buffer for the next surface content update. Typically\n this is possible, when the compositor maintains a copy of the\n wl_surface contents, e.g. as a GL texture. This is an important\n optimization for GL(ES) compositors with wl_shm clients."]
    pub release: ::core::option::Option<
        unsafe extern "C" fn(data: *mut ::core::ffi::c_void, wl_buffer: *mut wl_buffer),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_buffer_listener"][::core::mem::size_of::<wl_buffer_listener>() - 8usize];
    ["Alignment of wl_buffer_listener"][::core::mem::align_of::<wl_buffer_listener>() - 8usize];
    ["Offset of field: wl_buffer_listener::release"]
        [::core::mem::offset_of!(wl_buffer_listener, release) - 0usize];
};
#[doc = " finish request was called untimely"]
pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_FINISH: wl_data_offer_error = 0;
#[doc = " action mask contains invalid values"]
pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK: wl_data_offer_error = 1;
#[doc = " action argument has an invalid value"]
pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_ACTION: wl_data_offer_error = 2;
#[doc = " offer doesn't accept this request"]
pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_OFFER: wl_data_offer_error = 3;
pub type wl_data_offer_error = ::core::ffi::c_uint;
#[doc = " @ingroup iface_wl_data_offer\n @struct wl_data_offer_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_offer_listener {
    #[doc = " advertise offered mime type\n\n Sent immediately after creating the wl_data_offer object. One\n event per offered mime type.\n @param mime_type offered mime type"]
    pub offer: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_data_offer: *mut wl_data_offer,
            mime_type: *const ::core::ffi::c_char,
        ),
    >,
    #[doc = " notify the source-side available actions\n\n This event indicates the actions offered by the data source.\n It will be sent immediately after creating the wl_data_offer\n object, or anytime the source side changes its offered actions\n through wl_data_source.set_actions.\n @param source_actions actions offered by the data source\n @since 3"]
    pub source_actions: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_data_offer: *mut wl_data_offer,
            source_actions: u32,
        ),
    >,
    #[doc = " notify the selected action\n\n This event indicates the action selected by the compositor\n after matching the source/destination side actions. Only one\n action (or none) will be offered here.\n\n This event can be emitted multiple times during the\n drag-and-drop operation in response to destination side action\n changes through wl_data_offer.set_actions.\n\n This event will no longer be emitted after wl_data_device.drop\n happened on the drag-and-drop destination, the client must honor\n the last action received, or the last preferred one set through\n wl_data_offer.set_actions when handling an \"ask\" action.\n\n Compositors may also change the selected action on the fly,\n mainly in response to keyboard modifier changes during the\n drag-and-drop operation.\n\n The most recent action received is always the valid one. Prior\n to receiving wl_data_device.drop, the chosen action may change\n (e.g. due to keyboard modifiers being pressed). At the time of\n receiving wl_data_device.drop the drag-and-drop destination must\n honor the last action received.\n\n Action changes may still happen after wl_data_device.drop,\n especially on \"ask\" actions, where the drag-and-drop destination\n may choose another action afterwards. Action changes happening\n at this stage are always the result of inter-client negotiation,\n the compositor shall no longer be able to induce a different\n action.\n\n Upon \"ask\" actions, it is expected that the drag-and-drop\n destination may potentially choose a different action and/or\n mime type, based on wl_data_offer.source_actions and finally\n chosen by the user (e.g. popping up a menu with the available\n options). The final wl_data_offer.set_actions and\n wl_data_offer.accept requests must happen before the call to\n wl_data_offer.finish.\n @param dnd_action action selected by the compositor\n @since 3"]
    pub action: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_data_offer: *mut wl_data_offer,
            dnd_action: u32,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_data_offer_listener"][::core::mem::size_of::<wl_data_offer_listener>() - 24usize];
    ["Alignment of wl_data_offer_listener"]
        [::core::mem::align_of::<wl_data_offer_listener>() - 8usize];
    ["Offset of field: wl_data_offer_listener::offer"]
        [::core::mem::offset_of!(wl_data_offer_listener, offer) - 0usize];
    ["Offset of field: wl_data_offer_listener::source_actions"]
        [::core::mem::offset_of!(wl_data_offer_listener, source_actions) - 8usize];
    ["Offset of field: wl_data_offer_listener::action"]
        [::core::mem::offset_of!(wl_data_offer_listener, action) - 16usize];
};
#[doc = " action mask contains invalid values"]
pub const wl_data_source_error_WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK: wl_data_source_error = 0;
#[doc = " source doesn't accept this request"]
pub const wl_data_source_error_WL_DATA_SOURCE_ERROR_INVALID_SOURCE: wl_data_source_error = 1;
pub type wl_data_source_error = ::core::ffi::c_uint;
#[doc = " @ingroup iface_wl_data_source\n @struct wl_data_source_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_source_listener {
    #[doc = " a target accepts an offered mime type\n\n Sent when a target accepts pointer_focus or motion events. If\n a target does not accept any of the offered types, type is NULL.\n\n Used for feedback during drag-and-drop.\n @param mime_type mime type accepted by the target"]
    pub target: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_data_source: *mut wl_data_source,
            mime_type: *const ::core::ffi::c_char,
        ),
    >,
    #[doc = " send the data\n\n Request for data from the client. Send the data as the\n specified mime type over the passed file descriptor, then close\n it.\n @param mime_type mime type for the data\n @param fd file descriptor for the data"]
    pub send: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_data_source: *mut wl_data_source,
            mime_type: *const ::core::ffi::c_char,
            fd: i32,
        ),
    >,
    #[doc = " selection was cancelled\n\n This data source is no longer valid. There are several reasons\n why this could happen:\n\n - The data source has been replaced by another data source. -\n The drag-and-drop operation was performed, but the drop\n destination did not accept any of the mime types offered through\n wl_data_source.target. - The drag-and-drop operation was\n performed, but the drop destination did not select any of the\n actions present in the mask offered through\n wl_data_source.action. - The drag-and-drop operation was\n performed but didn't happen over a surface. - The compositor\n cancelled the drag-and-drop operation (e.g. compositor dependent\n timeouts to avoid stale drag-and-drop transfers).\n\n The client should clean up and destroy this data source.\n\n For objects of version 2 or older, wl_data_source.cancelled will\n only be emitted if the data source was replaced by another data\n source."]
    pub cancelled: ::core::option::Option<
        unsafe extern "C" fn(data: *mut ::core::ffi::c_void, wl_data_source: *mut wl_data_source),
    >,
    #[doc = " the drag-and-drop operation physically finished\n\n The user performed the drop action. This event does not\n indicate acceptance, wl_data_source.cancelled may still be\n emitted afterwards if the drop destination does not accept any\n mime type.\n\n However, this event might however not be received if the\n compositor cancelled the drag-and-drop operation before this\n event could happen.\n\n Note that the data_source may still be used in the future and\n should not be destroyed here.\n @since 3"]
    pub dnd_drop_performed: ::core::option::Option<
        unsafe extern "C" fn(data: *mut ::core::ffi::c_void, wl_data_source: *mut wl_data_source),
    >,
    #[doc = " the drag-and-drop operation concluded\n\n The drop destination finished interoperating with this data\n source, so the client is now free to destroy this data source\n and free all associated data.\n\n If the action used to perform the operation was \"move\", the\n source can now delete the transferred data.\n @since 3"]
    pub dnd_finished: ::core::option::Option<
        unsafe extern "C" fn(data: *mut ::core::ffi::c_void, wl_data_source: *mut wl_data_source),
    >,
    #[doc = " notify the selected action\n\n This event indicates the action selected by the compositor\n after matching the source/destination side actions. Only one\n action (or none) will be offered here.\n\n This event can be emitted multiple times during the\n drag-and-drop operation, mainly in response to destination side\n changes through wl_data_offer.set_actions, and as the data\n device enters/leaves surfaces.\n\n It is only possible to receive this event after\n wl_data_source.dnd_drop_performed if the drag-and-drop operation\n ended in an \"ask\" action, in which case the final\n wl_data_source.action event will happen immediately before\n wl_data_source.dnd_finished.\n\n Compositors may also change the selected action on the fly,\n mainly in response to keyboard modifier changes during the\n drag-and-drop operation.\n\n The most recent action received is always the valid one. The\n chosen action may change alongside negotiation (e.g. an \"ask\"\n action can turn into a \"move\" operation), so the effects of the\n final action must always be applied in\n wl_data_offer.dnd_finished.\n\n Clients can trigger cursor surface changes from this point, so\n they reflect the current action.\n @param dnd_action action selected by the compositor\n @since 3"]
    pub action: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_data_source: *mut wl_data_source,
            dnd_action: u32,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_data_source_listener"]
        [::core::mem::size_of::<wl_data_source_listener>() - 48usize];
    ["Alignment of wl_data_source_listener"]
        [::core::mem::align_of::<wl_data_source_listener>() - 8usize];
    ["Offset of field: wl_data_source_listener::target"]
        [::core::mem::offset_of!(wl_data_source_listener, target) - 0usize];
    ["Offset of field: wl_data_source_listener::send"]
        [::core::mem::offset_of!(wl_data_source_listener, send) - 8usize];
    ["Offset of field: wl_data_source_listener::cancelled"]
        [::core::mem::offset_of!(wl_data_source_listener, cancelled) - 16usize];
    ["Offset of field: wl_data_source_listener::dnd_drop_performed"]
        [::core::mem::offset_of!(wl_data_source_listener, dnd_drop_performed) - 24usize];
    ["Offset of field: wl_data_source_listener::dnd_finished"]
        [::core::mem::offset_of!(wl_data_source_listener, dnd_finished) - 32usize];
    ["Offset of field: wl_data_source_listener::action"]
        [::core::mem::offset_of!(wl_data_source_listener, action) - 40usize];
};
#[doc = " given wl_surface has another role"]
pub const wl_data_device_error_WL_DATA_DEVICE_ERROR_ROLE: wl_data_device_error = 0;
#[doc = " source has already been used"]
pub const wl_data_device_error_WL_DATA_DEVICE_ERROR_USED_SOURCE: wl_data_device_error = 1;
pub type wl_data_device_error = ::core::ffi::c_uint;
#[doc = " @ingroup iface_wl_data_device\n @struct wl_data_device_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device_listener {
    #[doc = " introduce a new wl_data_offer\n\n The data_offer event introduces a new wl_data_offer object,\n which will subsequently be used in either the data_device.enter\n event (for drag-and-drop) or the data_device.selection event\n (for selections). Immediately following the\n data_device.data_offer event, the new data_offer object will\n send out data_offer.offer events to describe the mime types it\n offers.\n @param id the new data_offer object"]
    pub data_offer: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_data_device: *mut wl_data_device,
            id: *mut wl_data_offer,
        ),
    >,
    #[doc = " initiate drag-and-drop session\n\n This event is sent when an active drag-and-drop pointer enters\n a surface owned by the client. The position of the pointer at\n enter time is provided by the x and y arguments, in\n surface-local coordinates.\n @param serial serial number of the enter event\n @param surface client surface entered\n @param x surface-local x coordinate\n @param y surface-local y coordinate\n @param id source data_offer object"]
    pub enter: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_data_device: *mut wl_data_device,
            serial: u32,
            surface: *mut wl_surface,
            x: wl_fixed_t,
            y: wl_fixed_t,
            id: *mut wl_data_offer,
        ),
    >,
    #[doc = " end drag-and-drop session\n\n This event is sent when the drag-and-drop pointer leaves the\n surface and the session ends. The client must destroy the\n wl_data_offer introduced at enter time at this point."]
    pub leave: ::core::option::Option<
        unsafe extern "C" fn(data: *mut ::core::ffi::c_void, wl_data_device: *mut wl_data_device),
    >,
    #[doc = " drag-and-drop session motion\n\n This event is sent when the drag-and-drop pointer moves within\n the currently focused surface. The new position of the pointer\n is provided by the x and y arguments, in surface-local\n coordinates.\n @param time timestamp with millisecond granularity\n @param x surface-local x coordinate\n @param y surface-local y coordinate"]
    pub motion: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_data_device: *mut wl_data_device,
            time: u32,
            x: wl_fixed_t,
            y: wl_fixed_t,
        ),
    >,
    #[doc = " end drag-and-drop session successfully\n\n The event is sent when a drag-and-drop operation is ended\n because the implicit grab is removed.\n\n The drag-and-drop destination is expected to honor the last\n action received through wl_data_offer.action, if the resulting\n action is \"copy\" or \"move\", the destination can still perform\n wl_data_offer.receive requests, and is expected to end all\n transfers with a wl_data_offer.finish request.\n\n If the resulting action is \"ask\", the action will not be\n considered final. The drag-and-drop destination is expected to\n perform one last wl_data_offer.set_actions request, or\n wl_data_offer.destroy in order to cancel the operation."]
    pub drop: ::core::option::Option<
        unsafe extern "C" fn(data: *mut ::core::ffi::c_void, wl_data_device: *mut wl_data_device),
    >,
    #[doc = " advertise new selection\n\n The selection event is sent out to notify the client of a new\n wl_data_offer for the selection for this device. The\n data_device.data_offer and the data_offer.offer events are sent\n out immediately before this event to introduce the data offer\n object. The selection event is sent to a client immediately\n before receiving keyboard focus and when a new selection is set\n while the client has keyboard focus. The data_offer is valid\n until a new data_offer or NULL is received or until the client\n loses keyboard focus. Switching surface with keyboard focus\n within the same client doesn't mean a new selection will be\n sent. The client must destroy the previous selection data_offer,\n if any, upon receiving this event.\n @param id selection data_offer object"]
    pub selection: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_data_device: *mut wl_data_device,
            id: *mut wl_data_offer,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_data_device_listener"]
        [::core::mem::size_of::<wl_data_device_listener>() - 48usize];
    ["Alignment of wl_data_device_listener"]
        [::core::mem::align_of::<wl_data_device_listener>() - 8usize];
    ["Offset of field: wl_data_device_listener::data_offer"]
        [::core::mem::offset_of!(wl_data_device_listener, data_offer) - 0usize];
    ["Offset of field: wl_data_device_listener::enter"]
        [::core::mem::offset_of!(wl_data_device_listener, enter) - 8usize];
    ["Offset of field: wl_data_device_listener::leave"]
        [::core::mem::offset_of!(wl_data_device_listener, leave) - 16usize];
    ["Offset of field: wl_data_device_listener::motion"]
        [::core::mem::offset_of!(wl_data_device_listener, motion) - 24usize];
    ["Offset of field: wl_data_device_listener::drop"]
        [::core::mem::offset_of!(wl_data_device_listener, drop) - 32usize];
    ["Offset of field: wl_data_device_listener::selection"]
        [::core::mem::offset_of!(wl_data_device_listener, selection) - 40usize];
};
#[doc = " no action"]
pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE:
    wl_data_device_manager_dnd_action = 0;
#[doc = " copy action"]
pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY:
    wl_data_device_manager_dnd_action = 1;
#[doc = " move action"]
pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE:
    wl_data_device_manager_dnd_action = 2;
#[doc = " ask action"]
pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK:
    wl_data_device_manager_dnd_action = 4;
#[doc = " @ingroup iface_wl_data_device_manager\n drag and drop actions\n\n This is a bitmask of the available/preferred actions in a\n drag-and-drop operation.\n\n In the compositor, the selected action is a result of matching the\n actions offered by the source and destination sides.  \"action\" events\n with a \"none\" action will be sent to both source and destination if\n there is no match. All further checks will effectively happen on\n (source actions  destination actions).\n\n In addition, compositors may also pick different actions in\n reaction to key modifiers being pressed. One common design that\n is used in major toolkits (and the behavior recommended for\n compositors) is:\n\n - If no modifiers are pressed, the first match (in bit order)\n will be used.\n - Pressing Shift selects \"move\", if enabled in the mask.\n - Pressing Control selects \"copy\", if enabled in the mask.\n\n Behavior beyond that is considered implementation-dependent.\n Compositors may for example bind other modifiers (like Alt/Meta)\n or drags initiated with other buttons than BTN_LEFT to specific\n actions (e.g. \"ask\")."]
pub type wl_data_device_manager_dnd_action = ::core::ffi::c_uint;
#[doc = " given wl_surface has another role"]
pub const wl_shell_error_WL_SHELL_ERROR_ROLE: wl_shell_error = 0;
pub type wl_shell_error = ::core::ffi::c_uint;
#[doc = " no edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_NONE: wl_shell_surface_resize = 0;
#[doc = " top edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_TOP: wl_shell_surface_resize = 1;
#[doc = " bottom edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_BOTTOM: wl_shell_surface_resize = 2;
#[doc = " left edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_LEFT: wl_shell_surface_resize = 4;
#[doc = " top and left edges"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_TOP_LEFT: wl_shell_surface_resize = 5;
#[doc = " bottom and left edges"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT: wl_shell_surface_resize = 6;
#[doc = " right edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_RIGHT: wl_shell_surface_resize = 8;
#[doc = " top and right edges"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_TOP_RIGHT: wl_shell_surface_resize = 9;
#[doc = " bottom and right edges"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT: wl_shell_surface_resize =
    10;
#[doc = " @ingroup iface_wl_shell_surface\n edge values for resizing\n\n These values are used to indicate which edge of a surface\n is being dragged in a resize operation. The server may\n use this information to adapt its behavior, e.g. choose\n an appropriate cursor image."]
pub type wl_shell_surface_resize = ::core::ffi::c_uint;
#[doc = " do not set keyboard focus"]
pub const wl_shell_surface_transient_WL_SHELL_SURFACE_TRANSIENT_INACTIVE:
    wl_shell_surface_transient = 1;
#[doc = " @ingroup iface_wl_shell_surface\n details of transient behaviour\n\n These flags specify details of the expected behaviour\n of transient surfaces. Used in the set_transient request."]
pub type wl_shell_surface_transient = ::core::ffi::c_uint;
#[doc = " no preference, apply default policy"]
pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT:
    wl_shell_surface_fullscreen_method = 0;
#[doc = " scale, preserve the surface's aspect ratio and center on output"]
pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE:
    wl_shell_surface_fullscreen_method = 1;
#[doc = " switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch"]
pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER:
    wl_shell_surface_fullscreen_method = 2;
#[doc = " no upscaling, center on output and add black borders to compensate size mismatch"]
pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_FILL:
    wl_shell_surface_fullscreen_method = 3;
#[doc = " @ingroup iface_wl_shell_surface\n different method to set the surface fullscreen\n\n Hints to indicate to the compositor how to deal with a conflict\n between the dimensions of the surface and the dimensions of the\n output. The compositor is free to ignore this parameter."]
pub type wl_shell_surface_fullscreen_method = ::core::ffi::c_uint;
#[doc = " @ingroup iface_wl_shell_surface\n @struct wl_shell_surface_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell_surface_listener {
    #[doc = " ping client\n\n Ping a client to check if it is receiving events and sending\n requests. A client is expected to reply with a pong request.\n @param serial serial number of the ping"]
    pub ping: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_shell_surface: *mut wl_shell_surface,
            serial: u32,
        ),
    >,
    #[doc = " suggest resize\n\n The configure event asks the client to resize its surface.\n\n The size is a hint, in the sense that the client is free to\n ignore it if it doesn't resize, pick a smaller size (to satisfy\n aspect ratio or resize in steps of NxM pixels).\n\n The edges parameter provides a hint about how the surface was\n resized. The client may use this information to decide how to\n adjust its content to the new size (e.g. a scrolling area might\n adjust its content position to leave the viewable content\n unmoved).\n\n The client is free to dismiss all but the last configure event\n it received.\n\n The width and height arguments specify the size of the window in\n surface-local coordinates.\n @param edges how the surface was resized\n @param width new width of the surface\n @param height new height of the surface"]
    pub configure: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_shell_surface: *mut wl_shell_surface,
            edges: u32,
            width: i32,
            height: i32,
        ),
    >,
    #[doc = " popup interaction is done\n\n The popup_done event is sent out when a popup grab is broken,\n that is, when the user clicks a surface that doesn't belong to\n the client owning the popup surface."]
    pub popup_done: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_shell_surface: *mut wl_shell_surface,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_shell_surface_listener"]
        [::core::mem::size_of::<wl_shell_surface_listener>() - 24usize];
    ["Alignment of wl_shell_surface_listener"]
        [::core::mem::align_of::<wl_shell_surface_listener>() - 8usize];
    ["Offset of field: wl_shell_surface_listener::ping"]
        [::core::mem::offset_of!(wl_shell_surface_listener, ping) - 0usize];
    ["Offset of field: wl_shell_surface_listener::configure"]
        [::core::mem::offset_of!(wl_shell_surface_listener, configure) - 8usize];
    ["Offset of field: wl_shell_surface_listener::popup_done"]
        [::core::mem::offset_of!(wl_shell_surface_listener, popup_done) - 16usize];
};
#[doc = " buffer scale value is invalid"]
pub const wl_surface_error_WL_SURFACE_ERROR_INVALID_SCALE: wl_surface_error = 0;
#[doc = " buffer transform value is invalid"]
pub const wl_surface_error_WL_SURFACE_ERROR_INVALID_TRANSFORM: wl_surface_error = 1;
#[doc = " buffer size is invalid"]
pub const wl_surface_error_WL_SURFACE_ERROR_INVALID_SIZE: wl_surface_error = 2;
#[doc = " buffer offset is invalid"]
pub const wl_surface_error_WL_SURFACE_ERROR_INVALID_OFFSET: wl_surface_error = 3;
#[doc = " surface was destroyed before its role object"]
pub const wl_surface_error_WL_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT: wl_surface_error = 4;
#[doc = " @ingroup iface_wl_surface\n wl_surface error values\n\n These errors can be emitted in response to wl_surface requests."]
pub type wl_surface_error = ::core::ffi::c_uint;
#[doc = " @ingroup iface_wl_surface\n @struct wl_surface_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_surface_listener {
    #[doc = " surface enters an output\n\n This is emitted whenever a surface's creation, movement, or\n resizing results in some part of it being within the scanout\n region of an output.\n\n Note that a surface may be overlapping with zero or more\n outputs.\n @param output output entered by the surface"]
    pub enter: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_surface: *mut wl_surface,
            output: *mut wl_output,
        ),
    >,
    #[doc = " surface leaves an output\n\n This is emitted whenever a surface's creation, movement, or\n resizing results in it no longer having any part of it within\n the scanout region of an output.\n\n Clients should not use the number of outputs the surface is on\n for frame throttling purposes. The surface might be hidden even\n if no leave event has been sent, and the compositor might expect\n new surface content updates even if no enter event has been\n sent. The frame event should be used instead.\n @param output output left by the surface"]
    pub leave: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_surface: *mut wl_surface,
            output: *mut wl_output,
        ),
    >,
    #[doc = " preferred buffer scale for the surface\n\n This event indicates the preferred buffer scale for this\n surface. It is sent whenever the compositor's preference\n changes.\n\n Before receiving this event the preferred buffer scale for this\n surface is 1.\n\n It is intended that scaling aware clients use this event to\n scale their content and use wl_surface.set_buffer_scale to\n indicate the scale they have rendered with. This allows clients\n to supply a higher detail buffer.\n\n The compositor shall emit a scale value greater than 0.\n @param factor preferred scaling factor\n @since 6"]
    pub preferred_buffer_scale: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_surface: *mut wl_surface,
            factor: i32,
        ),
    >,
    #[doc = " preferred buffer transform for the surface\n\n This event indicates the preferred buffer transform for this\n surface. It is sent whenever the compositor's preference\n changes.\n\n Before receiving this event the preferred buffer transform for\n this surface is normal.\n\n Applying this transformation to the surface buffer contents and\n using wl_surface.set_buffer_transform might allow the compositor\n to use the surface buffer more efficiently.\n @param transform preferred transform\n @since 6"]
    pub preferred_buffer_transform: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_surface: *mut wl_surface,
            transform: u32,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_surface_listener"][::core::mem::size_of::<wl_surface_listener>() - 32usize];
    ["Alignment of wl_surface_listener"][::core::mem::align_of::<wl_surface_listener>() - 8usize];
    ["Offset of field: wl_surface_listener::enter"]
        [::core::mem::offset_of!(wl_surface_listener, enter) - 0usize];
    ["Offset of field: wl_surface_listener::leave"]
        [::core::mem::offset_of!(wl_surface_listener, leave) - 8usize];
    ["Offset of field: wl_surface_listener::preferred_buffer_scale"]
        [::core::mem::offset_of!(wl_surface_listener, preferred_buffer_scale) - 16usize];
    ["Offset of field: wl_surface_listener::preferred_buffer_transform"]
        [::core::mem::offset_of!(wl_surface_listener, preferred_buffer_transform) - 24usize];
};
#[doc = " the seat has pointer devices"]
pub const wl_seat_capability_WL_SEAT_CAPABILITY_POINTER: wl_seat_capability = 1;
#[doc = " the seat has one or more keyboards"]
pub const wl_seat_capability_WL_SEAT_CAPABILITY_KEYBOARD: wl_seat_capability = 2;
#[doc = " the seat has touch devices"]
pub const wl_seat_capability_WL_SEAT_CAPABILITY_TOUCH: wl_seat_capability = 4;
#[doc = " @ingroup iface_wl_seat\n seat capability bitmask\n\n This is a bitmask of capabilities this seat has; if a member is\n set, then it is present on the seat."]
pub type wl_seat_capability = ::core::ffi::c_uint;
#[doc = " get_pointer, get_keyboard or get_touch called on seat without the matching capability"]
pub const wl_seat_error_WL_SEAT_ERROR_MISSING_CAPABILITY: wl_seat_error = 0;
#[doc = " @ingroup iface_wl_seat\n wl_seat error values\n\n These errors can be emitted in response to wl_seat requests."]
pub type wl_seat_error = ::core::ffi::c_uint;
#[doc = " @ingroup iface_wl_seat\n @struct wl_seat_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_seat_listener {
    #[doc = " seat capabilities changed\n\n This is emitted whenever a seat gains or loses the pointer,\n keyboard or touch capabilities. The argument is a capability\n enum containing the complete set of capabilities this seat has.\n\n When the pointer capability is added, a client may create a\n wl_pointer object using the wl_seat.get_pointer request. This\n object will receive pointer events until the capability is\n removed in the future.\n\n When the pointer capability is removed, a client should destroy\n the wl_pointer objects associated with the seat where the\n capability was removed, using the wl_pointer.release request. No\n further pointer events will be received on these objects.\n\n In some compositors, if a seat regains the pointer capability\n and a client has a previously obtained wl_pointer object of\n version 4 or less, that object may start sending pointer events\n again. This behavior is considered a misinterpretation of the\n intended behavior and must not be relied upon by the client.\n wl_pointer objects of version 5 or later must not send events if\n created before the most recent event notifying the client of an\n added pointer capability.\n\n The above behavior also applies to wl_keyboard and wl_touch with\n the keyboard and touch capabilities, respectively.\n @param capabilities capabilities of the seat"]
    pub capabilities: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_seat: *mut wl_seat,
            capabilities: u32,
        ),
    >,
    #[doc = " unique identifier for this seat\n\n In a multi-seat configuration the seat name can be used by\n clients to help identify which physical devices the seat\n represents.\n\n The seat name is a UTF-8 string with no convention defined for\n its contents. Each name is unique among all wl_seat globals. The\n name is only guaranteed to be unique for the current compositor\n instance.\n\n The same seat names are used for all clients. Thus, the name can\n be shared across processes to refer to a specific wl_seat\n global.\n\n The name event is sent after binding to the seat global. This\n event is only sent once per seat object, and the name does not\n change over the lifetime of the wl_seat global.\n\n Compositors may re-use the same seat name if the wl_seat global\n is destroyed and re-created later.\n @param name seat identifier\n @since 2"]
    pub name: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_seat: *mut wl_seat,
            name: *const ::core::ffi::c_char,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_seat_listener"][::core::mem::size_of::<wl_seat_listener>() - 16usize];
    ["Alignment of wl_seat_listener"][::core::mem::align_of::<wl_seat_listener>() - 8usize];
    ["Offset of field: wl_seat_listener::capabilities"]
        [::core::mem::offset_of!(wl_seat_listener, capabilities) - 0usize];
    ["Offset of field: wl_seat_listener::name"]
        [::core::mem::offset_of!(wl_seat_listener, name) - 8usize];
};
#[doc = " given wl_surface has another role"]
pub const wl_pointer_error_WL_POINTER_ERROR_ROLE: wl_pointer_error = 0;
pub type wl_pointer_error = ::core::ffi::c_uint;
#[doc = " the button is not pressed"]
pub const wl_pointer_button_state_WL_POINTER_BUTTON_STATE_RELEASED: wl_pointer_button_state = 0;
#[doc = " the button is pressed"]
pub const wl_pointer_button_state_WL_POINTER_BUTTON_STATE_PRESSED: wl_pointer_button_state = 1;
#[doc = " @ingroup iface_wl_pointer\n physical button state\n\n Describes the physical state of a button that produced the button\n event."]
pub type wl_pointer_button_state = ::core::ffi::c_uint;
#[doc = " vertical axis"]
pub const wl_pointer_axis_WL_POINTER_AXIS_VERTICAL_SCROLL: wl_pointer_axis = 0;
#[doc = " horizontal axis"]
pub const wl_pointer_axis_WL_POINTER_AXIS_HORIZONTAL_SCROLL: wl_pointer_axis = 1;
#[doc = " @ingroup iface_wl_pointer\n axis types\n\n Describes the axis types of scroll events."]
pub type wl_pointer_axis = ::core::ffi::c_uint;
#[doc = " a physical wheel rotation"]
pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_WHEEL: wl_pointer_axis_source = 0;
#[doc = " finger on a touch surface"]
pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_FINGER: wl_pointer_axis_source = 1;
#[doc = " continuous coordinate space"]
pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_CONTINUOUS: wl_pointer_axis_source = 2;
#[doc = " a physical wheel tilt\n @since 6"]
pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_WHEEL_TILT: wl_pointer_axis_source = 3;
#[doc = " @ingroup iface_wl_pointer\n axis source types\n\n Describes the source types for axis events. This indicates to the\n client how an axis event was physically generated; a client may\n adjust the user interface accordingly. For example, scroll events\n from a \"finger\" source may be in a smooth coordinate space with\n kinetic scrolling whereas a \"wheel\" source may be in discrete steps\n of a number of lines.\n\n The \"continuous\" axis source is a device generating events in a\n continuous coordinate space, but using something other than a\n finger. One example for this source is button-based scrolling where\n the vertical motion of a device is converted to scroll events while\n a button is held down.\n\n The \"wheel tilt\" axis source indicates that the actual device is a\n wheel but the scroll event is not caused by a rotation but a\n (usually sideways) tilt of the wheel."]
pub type wl_pointer_axis_source = ::core::ffi::c_uint;
#[doc = " physical motion matches axis direction"]
pub const wl_pointer_axis_relative_direction_WL_POINTER_AXIS_RELATIVE_DIRECTION_IDENTICAL:
    wl_pointer_axis_relative_direction = 0;
#[doc = " physical motion is the inverse of the axis direction"]
pub const wl_pointer_axis_relative_direction_WL_POINTER_AXIS_RELATIVE_DIRECTION_INVERTED:
    wl_pointer_axis_relative_direction = 1;
#[doc = " @ingroup iface_wl_pointer\n axis relative direction\n\n This specifies the direction of the physical motion that caused a\n wl_pointer.axis event, relative to the wl_pointer.axis direction."]
pub type wl_pointer_axis_relative_direction = ::core::ffi::c_uint;
#[doc = " @ingroup iface_wl_pointer\n @struct wl_pointer_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_pointer_listener {
    #[doc = " enter event\n\n Notification that this seat's pointer is focused on a certain\n surface.\n\n When a seat's focus enters a surface, the pointer image is\n undefined and a client should respond to this event by setting\n an appropriate pointer image with the set_cursor request.\n @param serial serial number of the enter event\n @param surface surface entered by the pointer\n @param surface_x surface-local x coordinate\n @param surface_y surface-local y coordinate"]
    pub enter: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_pointer: *mut wl_pointer,
            serial: u32,
            surface: *mut wl_surface,
            surface_x: wl_fixed_t,
            surface_y: wl_fixed_t,
        ),
    >,
    #[doc = " leave event\n\n Notification that this seat's pointer is no longer focused on\n a certain surface.\n\n The leave notification is sent before the enter notification for\n the new focus.\n @param serial serial number of the leave event\n @param surface surface left by the pointer"]
    pub leave: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_pointer: *mut wl_pointer,
            serial: u32,
            surface: *mut wl_surface,
        ),
    >,
    #[doc = " pointer motion event\n\n Notification of pointer location change. The arguments\n surface_x and surface_y are the location relative to the focused\n surface.\n @param time timestamp with millisecond granularity\n @param surface_x surface-local x coordinate\n @param surface_y surface-local y coordinate"]
    pub motion: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_pointer: *mut wl_pointer,
            time: u32,
            surface_x: wl_fixed_t,
            surface_y: wl_fixed_t,
        ),
    >,
    #[doc = " pointer button event\n\n Mouse button click and release notifications.\n\n The location of the click is given by the last motion or enter\n event. The time argument is a timestamp with millisecond\n granularity, with an undefined base.\n\n The button is a button code as defined in the Linux kernel's\n linux/input-event-codes.h header file, e.g. BTN_LEFT.\n\n Any 16-bit button code value is reserved for future additions to\n the kernel's event code list. All other button codes above\n 0xFFFF are currently undefined but may be used in future\n versions of this protocol.\n @param serial serial number of the button event\n @param time timestamp with millisecond granularity\n @param button button that produced the event\n @param state physical state of the button"]
    pub button: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_pointer: *mut wl_pointer,
            serial: u32,
            time: u32,
            button: u32,
            state: u32,
        ),
    >,
    #[doc = " axis event\n\n Scroll and other axis notifications.\n\n For scroll events (vertical and horizontal scroll axes), the\n value parameter is the length of a vector along the specified\n axis in a coordinate space identical to those of motion events,\n representing a relative movement along the specified axis.\n\n For devices that support movements non-parallel to axes multiple\n axis events will be emitted.\n\n When applicable, for example for touch pads, the server can\n choose to emit scroll events where the motion vector is\n equivalent to a motion event vector.\n\n When applicable, a client can transform its content relative to\n the scroll distance.\n @param time timestamp with millisecond granularity\n @param axis axis type\n @param value length of vector in surface-local coordinate space"]
    pub axis: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_pointer: *mut wl_pointer,
            time: u32,
            axis: u32,
            value: wl_fixed_t,
        ),
    >,
    #[doc = " end of a pointer event sequence\n\n Indicates the end of a set of events that logically belong\n together. A client is expected to accumulate the data in all\n events within the frame before proceeding.\n\n All wl_pointer events before a wl_pointer.frame event belong\n logically together. For example, in a diagonal scroll motion the\n compositor will send an optional wl_pointer.axis_source event,\n two wl_pointer.axis events (horizontal and vertical) and finally\n a wl_pointer.frame event. The client may use this information to\n calculate a diagonal vector for scrolling.\n\n When multiple wl_pointer.axis events occur within the same\n frame, the motion vector is the combined motion of all events.\n When a wl_pointer.axis and a wl_pointer.axis_stop event occur\n within the same frame, this indicates that axis movement in one\n axis has stopped but continues in the other axis. When multiple\n wl_pointer.axis_stop events occur within the same frame, this\n indicates that these axes stopped in the same instance.\n\n A wl_pointer.frame event is sent for every logical event group,\n even if the group only contains a single wl_pointer event.\n Specifically, a client may get a sequence: motion, frame,\n button, frame, axis, frame, axis_stop, frame.\n\n The wl_pointer.enter and wl_pointer.leave events are logical\n events generated by the compositor and not the hardware. These\n events are also grouped by a wl_pointer.frame. When a pointer\n moves from one surface to another, a compositor should group the\n wl_pointer.leave event within the same wl_pointer.frame.\n However, a client must not rely on wl_pointer.leave and\n wl_pointer.enter being in the same wl_pointer.frame.\n Compositor-specific policies may require the wl_pointer.leave\n and wl_pointer.enter event being split across multiple\n wl_pointer.frame groups.\n @since 5"]
    pub frame: ::core::option::Option<
        unsafe extern "C" fn(data: *mut ::core::ffi::c_void, wl_pointer: *mut wl_pointer),
    >,
    #[doc = " axis source event\n\n Source information for scroll and other axes.\n\n This event does not occur on its own. It is sent before a\n wl_pointer.frame event and carries the source information for\n all events within that frame.\n\n The source specifies how this event was generated. If the source\n is wl_pointer.axis_source.finger, a wl_pointer.axis_stop event\n will be sent when the user lifts the finger off the device.\n\n If the source is wl_pointer.axis_source.wheel,\n wl_pointer.axis_source.wheel_tilt or\n wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event\n may or may not be sent. Whether a compositor sends an axis_stop\n event for these sources is hardware-specific and\n implementation-dependent; clients must not rely on receiving an\n axis_stop event for these scroll sources and should treat scroll\n sequences from these scroll sources as unterminated by default.\n\n This event is optional. If the source is unknown for a\n particular axis event sequence, no event is sent. Only one\n wl_pointer.axis_source event is permitted per frame.\n\n The order of wl_pointer.axis_discrete and wl_pointer.axis_source\n is not guaranteed.\n @param axis_source source of the axis event\n @since 5"]
    pub axis_source: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_pointer: *mut wl_pointer,
            axis_source: u32,
        ),
    >,
    #[doc = " axis stop event\n\n Stop notification for scroll and other axes.\n\n For some wl_pointer.axis_source types, a wl_pointer.axis_stop\n event is sent to notify a client that the axis sequence has\n terminated. This enables the client to implement kinetic\n scrolling. See the wl_pointer.axis_source documentation for\n information on when this event may be generated.\n\n Any wl_pointer.axis events with the same axis_source after this\n event should be considered as the start of a new axis motion.\n\n The timestamp is to be interpreted identical to the timestamp in\n the wl_pointer.axis event. The timestamp value may be the same\n as a preceding wl_pointer.axis event.\n @param time timestamp with millisecond granularity\n @param axis the axis stopped with this event\n @since 5"]
    pub axis_stop: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_pointer: *mut wl_pointer,
            time: u32,
            axis: u32,
        ),
    >,
    #[doc = " axis click event\n\n Discrete step information for scroll and other axes.\n\n This event carries the axis value of the wl_pointer.axis event\n in discrete steps (e.g. mouse wheel clicks).\n\n This event is deprecated with wl_pointer version 8 - this event\n is not sent to clients supporting version 8 or later.\n\n This event does not occur on its own, it is coupled with a\n wl_pointer.axis event that represents this axis value on a\n continuous scale. The protocol guarantees that each\n axis_discrete event is always followed by exactly one axis event\n with the same axis number within the same wl_pointer.frame. Note\n that the protocol allows for other events to occur between the\n axis_discrete and its coupled axis event, including other\n axis_discrete or axis events. A wl_pointer.frame must not\n contain more than one axis_discrete event per axis type.\n\n This event is optional; continuous scrolling devices like\n two-finger scrolling on touchpads do not have discrete steps and\n do not generate this event.\n\n The discrete value carries the directional information. e.g. a\n value of -2 is two steps towards the negative direction of this\n axis.\n\n The axis number is identical to the axis number in the\n associated axis event.\n\n The order of wl_pointer.axis_discrete and wl_pointer.axis_source\n is not guaranteed.\n @param axis axis type\n @param discrete number of steps\n @since 5\n @deprecated Deprecated since version 8"]
    pub axis_discrete: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_pointer: *mut wl_pointer,
            axis: u32,
            discrete: i32,
        ),
    >,
    #[doc = " axis high-resolution scroll event\n\n Discrete high-resolution scroll information.\n\n This event carries high-resolution wheel scroll information,\n with each multiple of 120 representing one logical scroll step\n (a wheel detent). For example, an axis_value120 of 30 is one\n quarter of a logical scroll step in the positive direction, a\n value120 of -240 are two logical scroll steps in the negative\n direction within the same hardware event. Clients that rely on\n discrete scrolling should accumulate the value120 to multiples\n of 120 before processing the event.\n\n The value120 must not be zero.\n\n This event replaces the wl_pointer.axis_discrete event in\n clients supporting wl_pointer version 8 or later.\n\n Where a wl_pointer.axis_source event occurs in the same\n wl_pointer.frame, the axis source applies to this event.\n\n The order of wl_pointer.axis_value120 and wl_pointer.axis_source\n is not guaranteed.\n @param axis axis type\n @param value120 scroll distance as fraction of 120\n @since 8"]
    pub axis_value120: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_pointer: *mut wl_pointer,
            axis: u32,
            value120: i32,
        ),
    >,
    #[doc = " axis relative physical direction event\n\n Relative directional information of the entity causing the\n axis motion.\n\n For a wl_pointer.axis event, the\n wl_pointer.axis_relative_direction event specifies the movement\n direction of the entity causing the wl_pointer.axis event. For\n example: - if a user's fingers on a touchpad move down and this\n causes a wl_pointer.axis vertical_scroll down event, the\n physical direction is 'identical' - if a user's fingers on a\n touchpad move down and this causes a wl_pointer.axis\n vertical_scroll up scroll up event ('natural scrolling'), the\n physical direction is 'inverted'.\n\n A client may use this information to adjust scroll motion of\n components. Specifically, enabling natural scrolling causes the\n content to change direction compared to traditional scrolling.\n Some widgets like volume control sliders should usually match\n the physical direction regardless of whether natural scrolling\n is active. This event enables clients to match the scroll\n direction of a widget to the physical direction.\n\n This event does not occur on its own, it is coupled with a\n wl_pointer.axis event that represents this axis value. The\n protocol guarantees that each axis_relative_direction event is\n always followed by exactly one axis event with the same axis\n number within the same wl_pointer.frame. Note that the protocol\n allows for other events to occur between the\n axis_relative_direction and its coupled axis event.\n\n The axis number is identical to the axis number in the\n associated axis event.\n\n The order of wl_pointer.axis_relative_direction,\n wl_pointer.axis_discrete and wl_pointer.axis_source is not\n guaranteed.\n @param axis axis type\n @param direction physical direction relative to axis motion\n @since 9"]
    pub axis_relative_direction: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_pointer: *mut wl_pointer,
            axis: u32,
            direction: u32,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_pointer_listener"][::core::mem::size_of::<wl_pointer_listener>() - 88usize];
    ["Alignment of wl_pointer_listener"][::core::mem::align_of::<wl_pointer_listener>() - 8usize];
    ["Offset of field: wl_pointer_listener::enter"]
        [::core::mem::offset_of!(wl_pointer_listener, enter) - 0usize];
    ["Offset of field: wl_pointer_listener::leave"]
        [::core::mem::offset_of!(wl_pointer_listener, leave) - 8usize];
    ["Offset of field: wl_pointer_listener::motion"]
        [::core::mem::offset_of!(wl_pointer_listener, motion) - 16usize];
    ["Offset of field: wl_pointer_listener::button"]
        [::core::mem::offset_of!(wl_pointer_listener, button) - 24usize];
    ["Offset of field: wl_pointer_listener::axis"]
        [::core::mem::offset_of!(wl_pointer_listener, axis) - 32usize];
    ["Offset of field: wl_pointer_listener::frame"]
        [::core::mem::offset_of!(wl_pointer_listener, frame) - 40usize];
    ["Offset of field: wl_pointer_listener::axis_source"]
        [::core::mem::offset_of!(wl_pointer_listener, axis_source) - 48usize];
    ["Offset of field: wl_pointer_listener::axis_stop"]
        [::core::mem::offset_of!(wl_pointer_listener, axis_stop) - 56usize];
    ["Offset of field: wl_pointer_listener::axis_discrete"]
        [::core::mem::offset_of!(wl_pointer_listener, axis_discrete) - 64usize];
    ["Offset of field: wl_pointer_listener::axis_value120"]
        [::core::mem::offset_of!(wl_pointer_listener, axis_value120) - 72usize];
    ["Offset of field: wl_pointer_listener::axis_relative_direction"]
        [::core::mem::offset_of!(wl_pointer_listener, axis_relative_direction) - 80usize];
};
#[doc = " no keymap; client must understand how to interpret the raw keycode"]
pub const wl_keyboard_keymap_format_WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP: wl_keyboard_keymap_format =
    0;
#[doc = " libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode"]
pub const wl_keyboard_keymap_format_WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1: wl_keyboard_keymap_format = 1;
#[doc = " @ingroup iface_wl_keyboard\n keyboard mapping format\n\n This specifies the format of the keymap provided to the\n client with the wl_keyboard.keymap event."]
pub type wl_keyboard_keymap_format = ::core::ffi::c_uint;
#[doc = " key is not pressed"]
pub const wl_keyboard_key_state_WL_KEYBOARD_KEY_STATE_RELEASED: wl_keyboard_key_state = 0;
#[doc = " key is pressed"]
pub const wl_keyboard_key_state_WL_KEYBOARD_KEY_STATE_PRESSED: wl_keyboard_key_state = 1;
#[doc = " @ingroup iface_wl_keyboard\n physical key state\n\n Describes the physical state of a key that produced the key event."]
pub type wl_keyboard_key_state = ::core::ffi::c_uint;
#[doc = " @ingroup iface_wl_keyboard\n @struct wl_keyboard_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_keyboard_listener {
    #[doc = " keyboard mapping\n\n This event provides a file descriptor to the client which can\n be memory-mapped in read-only mode to provide a keyboard mapping\n description.\n\n From version 7 onwards, the fd must be mapped with MAP_PRIVATE\n by the recipient, as MAP_SHARED may fail.\n @param format keymap format\n @param fd keymap file descriptor\n @param size keymap size, in bytes"]
    pub keymap: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_keyboard: *mut wl_keyboard,
            format: u32,
            fd: i32,
            size: u32,
        ),
    >,
    #[doc = " enter event\n\n Notification that this seat's keyboard focus is on a certain\n surface.\n\n The compositor must send the wl_keyboard.modifiers event after\n this event.\n\n In the wl_keyboard logical state, this event sets the active\n surface to the surface argument and the keys currently logically\n down to the keys in the keys argument. The compositor must not\n send this event if the wl_keyboard already had an active surface\n immediately before this event.\n @param serial serial number of the enter event\n @param surface surface gaining keyboard focus\n @param keys the keys currently logically down"]
    pub enter: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_keyboard: *mut wl_keyboard,
            serial: u32,
            surface: *mut wl_surface,
            keys: *mut wl_array,
        ),
    >,
    #[doc = " leave event\n\n Notification that this seat's keyboard focus is no longer on a\n certain surface.\n\n The leave notification is sent before the enter notification for\n the new focus.\n\n In the wl_keyboard logical state, this event resets all values\n to their defaults. The compositor must not send this event if\n the active surface of the wl_keyboard was not equal to the\n surface argument immediately before this event.\n @param serial serial number of the leave event\n @param surface surface that lost keyboard focus"]
    pub leave: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_keyboard: *mut wl_keyboard,
            serial: u32,
            surface: *mut wl_surface,
        ),
    >,
    #[doc = " key event\n\n A key was pressed or released. The time argument is a\n timestamp with millisecond granularity, with an undefined base.\n\n The key is a platform-specific key code that can be interpreted\n by feeding it to the keyboard mapping (see the keymap event).\n\n If this event produces a change in modifiers, then the resulting\n wl_keyboard.modifiers event must be sent after this event.\n\n In the wl_keyboard logical state, this event adds the key to the\n keys currently logically down (if the state argument is pressed)\n or removes the key from the keys currently logically down (if\n the state argument is released). The compositor must not send\n this event if the wl_keyboard did not have an active surface\n immediately before this event. The compositor must not send this\n event if state is pressed (resp. released) and the key was\n already logically down (resp. was not logically down)\n immediately before this event.\n @param serial serial number of the key event\n @param time timestamp with millisecond granularity\n @param key key that produced the event\n @param state physical state of the key"]
    pub key: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_keyboard: *mut wl_keyboard,
            serial: u32,
            time: u32,
            key: u32,
            state: u32,
        ),
    >,
    #[doc = " modifier and group state\n\n Notifies clients that the modifier and/or group state has\n changed, and it should update its local state.\n\n The compositor may send this event without a surface of the\n client having keyboard focus, for example to tie modifier\n information to pointer focus instead. If a modifier event with\n pressed modifiers is sent without a prior enter event, the\n client can assume the modifier state is valid until it receives\n the next wl_keyboard.modifiers event. In order to reset the\n modifier state again, the compositor can send a\n wl_keyboard.modifiers event with no pressed modifiers.\n\n In the wl_keyboard logical state, this event updates the\n modifiers and group.\n @param serial serial number of the modifiers event\n @param mods_depressed depressed modifiers\n @param mods_latched latched modifiers\n @param mods_locked locked modifiers\n @param group keyboard layout"]
    pub modifiers: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_keyboard: *mut wl_keyboard,
            serial: u32,
            mods_depressed: u32,
            mods_latched: u32,
            mods_locked: u32,
            group: u32,
        ),
    >,
    #[doc = " repeat rate and delay\n\n Informs the client about the keyboard's repeat rate and delay.\n\n This event is sent as soon as the wl_keyboard object has been\n created, and is guaranteed to be received by the client before\n any key press event.\n\n Negative values for either rate or delay are illegal. A rate of\n zero will disable any repeating (regardless of the value of\n delay).\n\n This event can be sent later on as well with a new value if\n necessary, so clients should continue listening for the event\n past the creation of wl_keyboard.\n @param rate the rate of repeating keys in characters per second\n @param delay delay in milliseconds since key down until repeating starts\n @since 4"]
    pub repeat_info: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_keyboard: *mut wl_keyboard,
            rate: i32,
            delay: i32,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_keyboard_listener"][::core::mem::size_of::<wl_keyboard_listener>() - 48usize];
    ["Alignment of wl_keyboard_listener"][::core::mem::align_of::<wl_keyboard_listener>() - 8usize];
    ["Offset of field: wl_keyboard_listener::keymap"]
        [::core::mem::offset_of!(wl_keyboard_listener, keymap) - 0usize];
    ["Offset of field: wl_keyboard_listener::enter"]
        [::core::mem::offset_of!(wl_keyboard_listener, enter) - 8usize];
    ["Offset of field: wl_keyboard_listener::leave"]
        [::core::mem::offset_of!(wl_keyboard_listener, leave) - 16usize];
    ["Offset of field: wl_keyboard_listener::key"]
        [::core::mem::offset_of!(wl_keyboard_listener, key) - 24usize];
    ["Offset of field: wl_keyboard_listener::modifiers"]
        [::core::mem::offset_of!(wl_keyboard_listener, modifiers) - 32usize];
    ["Offset of field: wl_keyboard_listener::repeat_info"]
        [::core::mem::offset_of!(wl_keyboard_listener, repeat_info) - 40usize];
};
#[doc = " @ingroup iface_wl_touch\n @struct wl_touch_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_touch_listener {
    #[doc = " touch down event and beginning of a touch sequence\n\n A new touch point has appeared on the surface. This touch\n point is assigned a unique ID. Future events from this touch\n point reference this ID. The ID ceases to be valid after a touch\n up event and may be reused in the future.\n @param serial serial number of the touch down event\n @param time timestamp with millisecond granularity\n @param surface surface touched\n @param id the unique ID of this touch point\n @param x surface-local x coordinate\n @param y surface-local y coordinate"]
    pub down: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_touch: *mut wl_touch,
            serial: u32,
            time: u32,
            surface: *mut wl_surface,
            id: i32,
            x: wl_fixed_t,
            y: wl_fixed_t,
        ),
    >,
    #[doc = " end of a touch event sequence\n\n The touch point has disappeared. No further events will be\n sent for this touch point and the touch point's ID is released\n and may be reused in a future touch down event.\n @param serial serial number of the touch up event\n @param time timestamp with millisecond granularity\n @param id the unique ID of this touch point"]
    pub up: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_touch: *mut wl_touch,
            serial: u32,
            time: u32,
            id: i32,
        ),
    >,
    #[doc = " update of touch point coordinates\n\n A touch point has changed coordinates.\n @param time timestamp with millisecond granularity\n @param id the unique ID of this touch point\n @param x surface-local x coordinate\n @param y surface-local y coordinate"]
    pub motion: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_touch: *mut wl_touch,
            time: u32,
            id: i32,
            x: wl_fixed_t,
            y: wl_fixed_t,
        ),
    >,
    #[doc = " end of touch frame event\n\n Indicates the end of a set of events that logically belong\n together. A client is expected to accumulate the data in all\n events within the frame before proceeding.\n\n A wl_touch.frame terminates at least one event but otherwise no\n guarantee is provided about the set of events within a frame. A\n client must assume that any state not updated in a frame is\n unchanged from the previously known state."]
    pub frame: ::core::option::Option<
        unsafe extern "C" fn(data: *mut ::core::ffi::c_void, wl_touch: *mut wl_touch),
    >,
    #[doc = " touch session cancelled\n\n Sent if the compositor decides the touch stream is a global\n gesture. No further events are sent to the clients from that\n particular gesture. Touch cancellation applies to all touch\n points currently active on this client's surface. The client is\n responsible for finalizing the touch points, future touch points\n on this surface may reuse the touch point ID.\n\n No frame event is required after the cancel event."]
    pub cancel: ::core::option::Option<
        unsafe extern "C" fn(data: *mut ::core::ffi::c_void, wl_touch: *mut wl_touch),
    >,
    #[doc = " update shape of touch point\n\n Sent when a touchpoint has changed its shape.\n\n This event does not occur on its own. It is sent before a\n wl_touch.frame event and carries the new shape information for\n any previously reported, or new touch points of that frame.\n\n Other events describing the touch point such as wl_touch.down,\n wl_touch.motion or wl_touch.orientation may be sent within the\n same wl_touch.frame. A client should treat these events as a\n single logical touch point update. The order of wl_touch.shape,\n wl_touch.orientation and wl_touch.motion is not guaranteed. A\n wl_touch.down event is guaranteed to occur before the first\n wl_touch.shape event for this touch ID but both events may occur\n within the same wl_touch.frame.\n\n A touchpoint shape is approximated by an ellipse through the\n major and minor axis length. The major axis length describes the\n longer diameter of the ellipse, while the minor axis length\n describes the shorter diameter. Major and minor are orthogonal\n and both are specified in surface-local coordinates. The center\n of the ellipse is always at the touchpoint location as reported\n by wl_touch.down or wl_touch.move.\n\n This event is only sent by the compositor if the touch device\n supports shape reports. The client has to make reasonable\n assumptions about the shape if it did not receive this event.\n @param id the unique ID of this touch point\n @param major length of the major axis in surface-local coordinates\n @param minor length of the minor axis in surface-local coordinates\n @since 6"]
    pub shape: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_touch: *mut wl_touch,
            id: i32,
            major: wl_fixed_t,
            minor: wl_fixed_t,
        ),
    >,
    #[doc = " update orientation of touch point\n\n Sent when a touchpoint has changed its orientation.\n\n This event does not occur on its own. It is sent before a\n wl_touch.frame event and carries the new shape information for\n any previously reported, or new touch points of that frame.\n\n Other events describing the touch point such as wl_touch.down,\n wl_touch.motion or wl_touch.shape may be sent within the same\n wl_touch.frame. A client should treat these events as a single\n logical touch point update. The order of wl_touch.shape,\n wl_touch.orientation and wl_touch.motion is not guaranteed. A\n wl_touch.down event is guaranteed to occur before the first\n wl_touch.orientation event for this touch ID but both events may\n occur within the same wl_touch.frame.\n\n The orientation describes the clockwise angle of a touchpoint's\n major axis to the positive surface y-axis and is normalized to\n the -180 to +180 degree range. The granularity of orientation\n depends on the touch device, some devices only support binary\n rotation values between 0 and 90 degrees.\n\n This event is only sent by the compositor if the touch device\n supports orientation reports.\n @param id the unique ID of this touch point\n @param orientation angle between major axis and positive surface y-axis in degrees\n @since 6"]
    pub orientation: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_touch: *mut wl_touch,
            id: i32,
            orientation: wl_fixed_t,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_touch_listener"][::core::mem::size_of::<wl_touch_listener>() - 56usize];
    ["Alignment of wl_touch_listener"][::core::mem::align_of::<wl_touch_listener>() - 8usize];
    ["Offset of field: wl_touch_listener::down"]
        [::core::mem::offset_of!(wl_touch_listener, down) - 0usize];
    ["Offset of field: wl_touch_listener::up"]
        [::core::mem::offset_of!(wl_touch_listener, up) - 8usize];
    ["Offset of field: wl_touch_listener::motion"]
        [::core::mem::offset_of!(wl_touch_listener, motion) - 16usize];
    ["Offset of field: wl_touch_listener::frame"]
        [::core::mem::offset_of!(wl_touch_listener, frame) - 24usize];
    ["Offset of field: wl_touch_listener::cancel"]
        [::core::mem::offset_of!(wl_touch_listener, cancel) - 32usize];
    ["Offset of field: wl_touch_listener::shape"]
        [::core::mem::offset_of!(wl_touch_listener, shape) - 40usize];
    ["Offset of field: wl_touch_listener::orientation"]
        [::core::mem::offset_of!(wl_touch_listener, orientation) - 48usize];
};
#[doc = " unknown geometry"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_UNKNOWN: wl_output_subpixel = 0;
#[doc = " no geometry"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_NONE: wl_output_subpixel = 1;
#[doc = " horizontal RGB"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB: wl_output_subpixel = 2;
#[doc = " horizontal BGR"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR: wl_output_subpixel = 3;
#[doc = " vertical RGB"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_VERTICAL_RGB: wl_output_subpixel = 4;
#[doc = " vertical BGR"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_VERTICAL_BGR: wl_output_subpixel = 5;
#[doc = " @ingroup iface_wl_output\n subpixel geometry information\n\n This enumeration describes how the physical\n pixels on an output are laid out."]
pub type wl_output_subpixel = ::core::ffi::c_uint;
#[doc = " no transform"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_NORMAL: wl_output_transform = 0;
#[doc = " 90 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_90: wl_output_transform = 1;
#[doc = " 180 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_180: wl_output_transform = 2;
#[doc = " 270 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_270: wl_output_transform = 3;
#[doc = " 180 degree flip around a vertical axis"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED: wl_output_transform = 4;
#[doc = " flip and rotate 90 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED_90: wl_output_transform = 5;
#[doc = " flip and rotate 180 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED_180: wl_output_transform = 6;
#[doc = " flip and rotate 270 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED_270: wl_output_transform = 7;
#[doc = " @ingroup iface_wl_output\n transformation applied to buffer contents\n\n This describes transformations that clients and compositors apply to\n buffer contents.\n\n The flipped values correspond to an initial flip around a\n vertical axis followed by rotation.\n\n The purpose is mainly to allow clients to render accordingly and\n tell the compositor, so that for fullscreen surfaces, the\n compositor will still be able to scan out directly from client\n surfaces."]
pub type wl_output_transform = ::core::ffi::c_uint;
#[doc = " indicates this is the current mode"]
pub const wl_output_mode_WL_OUTPUT_MODE_CURRENT: wl_output_mode = 1;
#[doc = " indicates this is the preferred mode"]
pub const wl_output_mode_WL_OUTPUT_MODE_PREFERRED: wl_output_mode = 2;
#[doc = " @ingroup iface_wl_output\n mode information\n\n These flags describe properties of an output mode.\n They are used in the flags bitfield of the mode event."]
pub type wl_output_mode = ::core::ffi::c_uint;
#[doc = " @ingroup iface_wl_output\n @struct wl_output_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_output_listener {
    #[doc = " properties of the output\n\n The geometry event describes geometric properties of the\n output. The event is sent when binding to the output object and\n whenever any of the properties change.\n\n The physical size can be set to zero if it doesn't make sense\n for this output (e.g. for projectors or virtual outputs).\n\n The geometry event will be followed by a done event (starting\n from version 2).\n\n Clients should use wl_surface.preferred_buffer_transform instead\n of the transform advertised by this event to find the preferred\n buffer transform to use for a surface.\n\n Note: wl_output only advertises partial information about the\n output position and identification. Some compositors, for\n instance those not implementing a desktop-style output layout or\n those exposing virtual outputs, might fake this information.\n Instead of using x and y, clients should use\n xdg_output.logical_position. Instead of using make and model,\n clients should use name and description.\n @param x x position within the global compositor space\n @param y y position within the global compositor space\n @param physical_width width in millimeters of the output\n @param physical_height height in millimeters of the output\n @param subpixel subpixel orientation of the output\n @param make textual description of the manufacturer\n @param model textual description of the model\n @param transform additional transformation applied to buffer contents during presentation"]
    pub geometry: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_output: *mut wl_output,
            x: i32,
            y: i32,
            physical_width: i32,
            physical_height: i32,
            subpixel: i32,
            make: *const ::core::ffi::c_char,
            model: *const ::core::ffi::c_char,
            transform: i32,
        ),
    >,
    #[doc = " advertise available modes for the output\n\n The mode event describes an available mode for the output.\n\n The event is sent when binding to the output object and there\n will always be one mode, the current mode. The event is sent\n again if an output changes mode, for the mode that is now\n current. In other words, the current mode is always the last\n mode that was received with the current flag set.\n\n Non-current modes are deprecated. A compositor can decide to\n only advertise the current mode and never send other modes.\n Clients should not rely on non-current modes.\n\n The size of a mode is given in physical hardware units of the\n output device. This is not necessarily the same as the output\n size in the global compositor space. For instance, the output\n may be scaled, as described in wl_output.scale, or transformed,\n as described in wl_output.transform. Clients willing to retrieve\n the output size in the global compositor space should use\n xdg_output.logical_size instead.\n\n The vertical refresh rate can be set to zero if it doesn't make\n sense for this output (e.g. for virtual outputs).\n\n The mode event will be followed by a done event (starting from\n version 2).\n\n Clients should not use the refresh rate to schedule frames.\n Instead, they should use the wl_surface.frame event or the\n presentation-time protocol.\n\n Note: this information is not always meaningful for all outputs.\n Some compositors, such as those exposing virtual outputs, might\n fake the refresh rate or the size.\n @param flags bitfield of mode flags\n @param width width of the mode in hardware units\n @param height height of the mode in hardware units\n @param refresh vertical refresh rate in mHz"]
    pub mode: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_output: *mut wl_output,
            flags: u32,
            width: i32,
            height: i32,
            refresh: i32,
        ),
    >,
    #[doc = " sent all information about output\n\n This event is sent after all other properties have been sent\n after binding to the output object and after any other property\n changes done after that. This allows changes to the output\n properties to be seen as atomic, even if they happen via\n multiple events.\n @since 2"]
    pub done: ::core::option::Option<
        unsafe extern "C" fn(data: *mut ::core::ffi::c_void, wl_output: *mut wl_output),
    >,
    #[doc = " output scaling properties\n\n This event contains scaling geometry information that is not\n in the geometry event. It may be sent after binding the output\n object or if the output scale changes later. The compositor will\n emit a non-zero, positive value for scale. If it is not sent,\n the client should assume a scale of 1.\n\n A scale larger than 1 means that the compositor will\n automatically scale surface buffers by this amount when\n rendering. This is used for very high resolution displays where\n applications rendering at the native resolution would be too\n small to be legible.\n\n Clients should use wl_surface.preferred_buffer_scale instead of\n this event to find the preferred buffer scale to use for a\n surface.\n\n The scale event will be followed by a done event.\n @param factor scaling factor of output\n @since 2"]
    pub scale: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_output: *mut wl_output,
            factor: i32,
        ),
    >,
    #[doc = " name of this output\n\n Many compositors will assign user-friendly names to their\n outputs, show them to the user, allow the user to refer to an\n output, etc. The client may wish to know this name as well to\n offer the user similar behaviors.\n\n The name is a UTF-8 string with no convention defined for its\n contents. Each name is unique among all wl_output globals. The\n name is only guaranteed to be unique for the compositor\n instance.\n\n The same output name is used for all clients for a given\n wl_output global. Thus, the name can be shared across processes\n to refer to a specific wl_output global.\n\n The name is not guaranteed to be persistent across sessions,\n thus cannot be used to reliably identify an output in e.g.\n configuration files.\n\n Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc.\n However, do not assume that the name is a reflection of an\n underlying DRM connector, X11 connection, etc.\n\n The name event is sent after binding the output object. This\n event is only sent once per output object, and the name does not\n change over the lifetime of the wl_output global.\n\n Compositors may re-use the same output name if the wl_output\n global is destroyed and re-created later. Compositors should\n avoid re-using the same name if possible.\n\n The name event will be followed by a done event.\n @param name output name\n @since 4"]
    pub name: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_output: *mut wl_output,
            name: *const ::core::ffi::c_char,
        ),
    >,
    #[doc = " human-readable description of this output\n\n Many compositors can produce human-readable descriptions of\n their outputs. The client may wish to know this description as\n well, e.g. for output selection purposes.\n\n The description is a UTF-8 string with no convention defined for\n its contents. The description is not guaranteed to be unique\n among all wl_output globals. Examples might include 'Foocorp 11\"\n Display' or 'Virtual X11 output via :1'.\n\n The description event is sent after binding the output object\n and whenever the description changes. The description is\n optional, and may not be sent at all.\n\n The description event will be followed by a done event.\n @param description output description\n @since 4"]
    pub description: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            wl_output: *mut wl_output,
            description: *const ::core::ffi::c_char,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_output_listener"][::core::mem::size_of::<wl_output_listener>() - 48usize];
    ["Alignment of wl_output_listener"][::core::mem::align_of::<wl_output_listener>() - 8usize];
    ["Offset of field: wl_output_listener::geometry"]
        [::core::mem::offset_of!(wl_output_listener, geometry) - 0usize];
    ["Offset of field: wl_output_listener::mode"]
        [::core::mem::offset_of!(wl_output_listener, mode) - 8usize];
    ["Offset of field: wl_output_listener::done"]
        [::core::mem::offset_of!(wl_output_listener, done) - 16usize];
    ["Offset of field: wl_output_listener::scale"]
        [::core::mem::offset_of!(wl_output_listener, scale) - 24usize];
    ["Offset of field: wl_output_listener::name"]
        [::core::mem::offset_of!(wl_output_listener, name) - 32usize];
    ["Offset of field: wl_output_listener::description"]
        [::core::mem::offset_of!(wl_output_listener, description) - 40usize];
};
#[doc = " the to-be sub-surface is invalid"]
pub const wl_subcompositor_error_WL_SUBCOMPOSITOR_ERROR_BAD_SURFACE: wl_subcompositor_error = 0;
#[doc = " the to-be sub-surface parent is invalid"]
pub const wl_subcompositor_error_WL_SUBCOMPOSITOR_ERROR_BAD_PARENT: wl_subcompositor_error = 1;
pub type wl_subcompositor_error = ::core::ffi::c_uint;
#[doc = " wl_surface is not a sibling or the parent"]
pub const wl_subsurface_error_WL_SUBSURFACE_ERROR_BAD_SURFACE: wl_subsurface_error = 0;
pub type wl_subsurface_error = ::core::ffi::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::core::ffi::c_ulong;
pub type ushort = ::core::ffi::c_ushort;
pub type uint = ::core::ffi::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::core::ffi::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::core::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::core::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::core::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::core::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::core::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::core::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::core::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::core::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::core::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::core::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::core::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::core::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::core::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::core::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::core::ffi::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::core::ffi::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::core::ffi::c_uint,
    pub __high: ::core::ffi::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter__bindgen_ty_1"]
        [::core::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>() - 8usize];
    ["Alignment of __atomic_wide_counter__bindgen_ty_1"]
        [::core::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>() - 4usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"]
        [::core::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"]
        [::core::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter"][::core::mem::size_of::<__atomic_wide_counter>() - 8usize];
    ["Alignment of __atomic_wide_counter"]
        [::core::mem::align_of::<__atomic_wide_counter>() - 8usize];
    ["Offset of field: __atomic_wide_counter::__value64"]
        [::core::mem::offset_of!(__atomic_wide_counter, __value64) - 0usize];
    ["Offset of field: __atomic_wide_counter::__value32"]
        [::core::mem::offset_of!(__atomic_wide_counter, __value32) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"]
        [::core::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::core::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::core::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::core::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::core::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::core::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::core::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::core::ffi::c_int,
    pub __count: ::core::ffi::c_uint,
    pub __owner: ::core::ffi::c_int,
    pub __nusers: ::core::ffi::c_uint,
    pub __kind: ::core::ffi::c_int,
    pub __spins: ::core::ffi::c_short,
    pub __elision: ::core::ffi::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::core::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::core::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::core::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::core::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::core::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::core::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::core::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::core::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::core::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::core::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::core::ffi::c_uint,
    pub __writers: ::core::ffi::c_uint,
    pub __wrphase_futex: ::core::ffi::c_uint,
    pub __writers_futex: ::core::ffi::c_uint,
    pub __pad3: ::core::ffi::c_uint,
    pub __pad4: ::core::ffi::c_uint,
    pub __cur_writer: ::core::ffi::c_int,
    pub __shared: ::core::ffi::c_int,
    pub __rwelision: ::core::ffi::c_schar,
    pub __pad1: [::core::ffi::c_uchar; 7usize],
    pub __pad2: ::core::ffi::c_ulong,
    pub __flags: ::core::ffi::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"]
        [::core::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::core::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_size: [::core::ffi::c_uint; 2usize],
    pub __g1_orig_size: ::core::ffi::c_uint,
    pub __wrefs: ::core::ffi::c_uint,
    pub __g_signals: [::core::ffi::c_uint; 2usize],
    pub __unused_initialized_1: ::core::ffi::c_uint,
    pub __unused_initialized_2: ::core::ffi::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::core::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::core::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__wseq"]
        [::core::mem::offset_of!(__pthread_cond_s, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s::__g1_start"]
        [::core::mem::offset_of!(__pthread_cond_s, __g1_start) - 8usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::core::mem::offset_of!(__pthread_cond_s, __g_size) - 16usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::core::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::core::mem::offset_of!(__pthread_cond_s, __wrefs) - 28usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::core::mem::offset_of!(__pthread_cond_s, __g_signals) - 32usize];
    ["Offset of field: __pthread_cond_s::__unused_initialized_1"]
        [::core::mem::offset_of!(__pthread_cond_s, __unused_initialized_1) - 40usize];
    ["Offset of field: __pthread_cond_s::__unused_initialized_2"]
        [::core::mem::offset_of!(__pthread_cond_s, __unused_initialized_2) - 44usize];
};
pub type __tss_t = ::core::ffi::c_uint;
pub type __thrd_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __once_flag"][::core::mem::size_of::<__once_flag>() - 4usize];
    ["Alignment of __once_flag"][::core::mem::align_of::<__once_flag>() - 4usize];
    ["Offset of field: __once_flag::__data"][::core::mem::offset_of!(__once_flag, __data) - 0usize];
};
pub type pthread_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::core::ffi::c_char; 4usize],
    pub __align: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::core::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::core::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::core::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::core::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::core::ffi::c_char; 4usize],
    pub __align: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::core::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::core::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::core::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::core::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::core::ffi::c_uint;
pub type pthread_once_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::core::ffi::c_char; 56usize],
    pub __align: ::core::ffi::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::core::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::core::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::core::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::core::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::core::ffi::c_char; 40usize],
    pub __align: ::core::ffi::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::core::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::core::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::core::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::core::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::core::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::core::ffi::c_char; 48usize],
    pub __align: ::core::ffi::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::core::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::core::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::core::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::core::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::core::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::core::ffi::c_char; 56usize],
    pub __align: ::core::ffi::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::core::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::core::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::core::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::core::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::core::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::core::ffi::c_char; 8usize],
    pub __align: ::core::ffi::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::core::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::core::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::core::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::core::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::core::ffi::c_char; 32usize],
    pub __align: ::core::ffi::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::core::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::core::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::core::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::core::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::core::ffi::c_char; 4usize],
    pub __align: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::core::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::core::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::core::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::core::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
pub const WL_EVENT_READABLE: _bindgen_ty_2 = 1;
pub const WL_EVENT_WRITABLE: _bindgen_ty_2 = 2;
pub const WL_EVENT_HANGUP: _bindgen_ty_2 = 4;
pub const WL_EVENT_ERROR: _bindgen_ty_2 = 8;
pub type _bindgen_ty_2 = ::core::ffi::c_uint;
#[doc = " File descriptor dispatch function type\n\n Functions of this type are used as callbacks for file descriptor events.\n\n \\param fd The file descriptor delivering the event.\n \\param mask Describes the kind of the event as a bitwise-or of:\n \\c WL_EVENT_READABLE, \\c WL_EVENT_WRITABLE, \\c WL_EVENT_HANGUP,\n \\c WL_EVENT_ERROR.\n \\param data The user data argument of the related wl_event_loop_add_fd()\n call.\n \\return If the event source is registered for re-check with\n wl_event_source_check(): 0 for all done, 1 for needing a re-check.\n If not registered, the return value is ignored and should be zero.\n\n \\sa wl_event_loop_add_fd()\n \\memberof wl_event_source"]
pub type wl_event_loop_fd_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        fd: ::core::ffi::c_int,
        mask: u32,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Timer dispatch function type\n\n Functions of this type are used as callbacks for timer expiry.\n\n \\param data The user data argument of the related wl_event_loop_add_timer()\n call.\n \\return If the event source is registered for re-check with\n wl_event_source_check(): 0 for all done, 1 for needing a re-check.\n If not registered, the return value is ignored and should be zero.\n\n \\sa wl_event_loop_add_timer()\n \\memberof wl_event_source"]
pub type wl_event_loop_timer_func_t = ::core::option::Option<
    unsafe extern "C" fn(data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
#[doc = " Signal dispatch function type\n\n Functions of this type are used as callbacks for (POSIX) signals.\n\n \\param signal_number\n \\param data The user data argument of the related wl_event_loop_add_signal()\n call.\n \\return If the event source is registered for re-check with\n wl_event_source_check(): 0 for all done, 1 for needing a re-check.\n If not registered, the return value is ignored and should be zero.\n\n \\sa wl_event_loop_add_signal()\n \\memberof wl_event_source"]
pub type wl_event_loop_signal_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        signal_number: ::core::ffi::c_int,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Idle task function type\n\n Functions of this type are used as callbacks before blocking in\n wl_event_loop_dispatch().\n\n \\param data The user data argument of the related wl_event_loop_add_idle()\n call.\n\n \\sa wl_event_loop_add_idle() wl_event_loop_dispatch()\n \\memberof wl_event_source"]
pub type wl_event_loop_idle_func_t =
    ::core::option::Option<unsafe extern "C" fn(data: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_event_loop {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " \\struct wl_event_source\n\n \\brief An abstract event source\n\n This is the generic type for fd, timer, signal, and idle sources.\n Functions that operate on specific source types must not be used with\n a different type, even if the function signature allows it."]
    pub fn wl_event_loop_create() -> *mut wl_event_loop;
}
unsafe extern "C" {
    pub fn wl_event_loop_destroy(loop_: *mut wl_event_loop);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_event_source {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn wl_event_loop_add_fd(
        loop_: *mut wl_event_loop,
        fd: ::core::ffi::c_int,
        mask: u32,
        func: wl_event_loop_fd_func_t,
        data: *mut ::core::ffi::c_void,
    ) -> *mut wl_event_source;
}
unsafe extern "C" {
    pub fn wl_event_source_fd_update(source: *mut wl_event_source, mask: u32)
        -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_event_loop_add_timer(
        loop_: *mut wl_event_loop,
        func: wl_event_loop_timer_func_t,
        data: *mut ::core::ffi::c_void,
    ) -> *mut wl_event_source;
}
unsafe extern "C" {
    pub fn wl_event_loop_add_signal(
        loop_: *mut wl_event_loop,
        signal_number: ::core::ffi::c_int,
        func: wl_event_loop_signal_func_t,
        data: *mut ::core::ffi::c_void,
    ) -> *mut wl_event_source;
}
unsafe extern "C" {
    pub fn wl_event_source_timer_update(
        source: *mut wl_event_source,
        ms_delay: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_event_source_remove(source: *mut wl_event_source) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_event_source_check(source: *mut wl_event_source);
}
unsafe extern "C" {
    pub fn wl_event_loop_dispatch(
        loop_: *mut wl_event_loop,
        timeout: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_event_loop_dispatch_idle(loop_: *mut wl_event_loop);
}
unsafe extern "C" {
    pub fn wl_event_loop_add_idle(
        loop_: *mut wl_event_loop,
        func: wl_event_loop_idle_func_t,
        data: *mut ::core::ffi::c_void,
    ) -> *mut wl_event_source;
}
unsafe extern "C" {
    pub fn wl_event_loop_get_fd(loop_: *mut wl_event_loop) -> ::core::ffi::c_int;
}
pub type wl_notify_func_t = ::core::option::Option<
    unsafe extern "C" fn(listener: *mut wl_listener, data: *mut ::core::ffi::c_void),
>;
unsafe extern "C" {
    pub fn wl_event_loop_add_destroy_listener(
        loop_: *mut wl_event_loop,
        listener: *mut wl_listener,
    );
}
unsafe extern "C" {
    pub fn wl_event_loop_get_destroy_listener(
        loop_: *mut wl_event_loop,
        notify: wl_notify_func_t,
    ) -> *mut wl_listener;
}
unsafe extern "C" {
    pub fn wl_display_create() -> *mut wl_display;
}
unsafe extern "C" {
    pub fn wl_display_destroy(display: *mut wl_display);
}
unsafe extern "C" {
    pub fn wl_display_get_event_loop(display: *mut wl_display) -> *mut wl_event_loop;
}
unsafe extern "C" {
    pub fn wl_display_add_socket(
        display: *mut wl_display,
        name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_display_add_socket_auto(display: *mut wl_display) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn wl_display_add_socket_fd(
        display: *mut wl_display,
        sock_fd: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_display_terminate(display: *mut wl_display);
}
unsafe extern "C" {
    pub fn wl_display_run(display: *mut wl_display);
}
unsafe extern "C" {
    pub fn wl_display_flush_clients(display: *mut wl_display);
}
unsafe extern "C" {
    pub fn wl_display_destroy_clients(display: *mut wl_display);
}
unsafe extern "C" {
    pub fn wl_display_set_default_max_buffer_size(display: *mut wl_display, max_buffer_size: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_client {
    _unused: [u8; 0],
}
pub type wl_global_bind_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        client: *mut wl_client,
        data: *mut ::core::ffi::c_void,
        version: u32,
        id: u32,
    ),
>;
unsafe extern "C" {
    pub fn wl_display_get_serial(display: *mut wl_display) -> u32;
}
unsafe extern "C" {
    pub fn wl_display_next_serial(display: *mut wl_display) -> u32;
}
unsafe extern "C" {
    pub fn wl_display_add_destroy_listener(display: *mut wl_display, listener: *mut wl_listener);
}
unsafe extern "C" {
    pub fn wl_display_add_client_created_listener(
        display: *mut wl_display,
        listener: *mut wl_listener,
    );
}
unsafe extern "C" {
    pub fn wl_display_get_destroy_listener(
        display: *mut wl_display,
        notify: wl_notify_func_t,
    ) -> *mut wl_listener;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_global {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn wl_global_create(
        display: *mut wl_display,
        interface: *const wl_interface,
        version: ::core::ffi::c_int,
        data: *mut ::core::ffi::c_void,
        bind: wl_global_bind_func_t,
    ) -> *mut wl_global;
}
unsafe extern "C" {
    pub fn wl_global_remove(global: *mut wl_global);
}
unsafe extern "C" {
    pub fn wl_global_destroy(global: *mut wl_global);
}
#[doc = " A filter function for wl_global objects\n\n \\param client The client object\n \\param global The global object to show or hide\n \\param data   The user data pointer\n\n A filter function enables the server to decide which globals to\n advertise to each client.\n\n When a wl_global filter is set, the given callback function will be\n called during wl_global advertisement and binding.\n\n This function should return true if the global object should be made\n visible to the client or false otherwise."]
pub type wl_display_global_filter_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        client: *const wl_client,
        global: *const wl_global,
        data: *mut ::core::ffi::c_void,
    ) -> bool,
>;
unsafe extern "C" {
    pub fn wl_display_set_global_filter(
        display: *mut wl_display,
        filter: wl_display_global_filter_func_t,
        data: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn wl_global_get_interface(global: *const wl_global) -> *const wl_interface;
}
unsafe extern "C" {
    pub fn wl_global_get_name(global: *const wl_global, client: *const wl_client) -> u32;
}
unsafe extern "C" {
    pub fn wl_global_get_version(global: *const wl_global) -> u32;
}
unsafe extern "C" {
    pub fn wl_global_get_display(global: *const wl_global) -> *mut wl_display;
}
unsafe extern "C" {
    pub fn wl_global_get_user_data(global: *const wl_global) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn wl_global_set_user_data(global: *mut wl_global, data: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    pub fn wl_client_create(display: *mut wl_display, fd: ::core::ffi::c_int) -> *mut wl_client;
}
unsafe extern "C" {
    pub fn wl_display_get_client_list(display: *mut wl_display) -> *mut wl_list;
}
unsafe extern "C" {
    pub fn wl_client_get_link(client: *mut wl_client) -> *mut wl_list;
}
unsafe extern "C" {
    pub fn wl_client_from_link(link: *mut wl_list) -> *mut wl_client;
}
unsafe extern "C" {
    pub fn wl_client_destroy(client: *mut wl_client);
}
unsafe extern "C" {
    pub fn wl_client_flush(client: *mut wl_client);
}
unsafe extern "C" {
    pub fn wl_client_get_credentials(
        client: *mut wl_client,
        pid: *mut pid_t,
        uid: *mut uid_t,
        gid: *mut gid_t,
    );
}
unsafe extern "C" {
    pub fn wl_client_get_fd(client: *mut wl_client) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_client_add_destroy_listener(client: *mut wl_client, listener: *mut wl_listener);
}
unsafe extern "C" {
    pub fn wl_client_get_destroy_listener(
        client: *mut wl_client,
        notify: wl_notify_func_t,
    ) -> *mut wl_listener;
}
unsafe extern "C" {
    pub fn wl_client_add_destroy_late_listener(client: *mut wl_client, listener: *mut wl_listener);
}
unsafe extern "C" {
    pub fn wl_client_get_destroy_late_listener(
        client: *mut wl_client,
        notify: wl_notify_func_t,
    ) -> *mut wl_listener;
}
unsafe extern "C" {
    pub fn wl_client_get_object(client: *mut wl_client, id: u32) -> *mut wl_resource;
}
unsafe extern "C" {
    pub fn wl_client_post_no_memory(client: *mut wl_client);
}
unsafe extern "C" {
    pub fn wl_client_post_implementation_error(
        client: *mut wl_client,
        msg: *const ::core::ffi::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn wl_client_add_resource_created_listener(
        client: *mut wl_client,
        listener: *mut wl_listener,
    );
}
pub type wl_client_for_each_resource_iterator_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        resource: *mut wl_resource,
        user_data: *mut ::core::ffi::c_void,
    ) -> wl_iterator_result,
>;
unsafe extern "C" {
    pub fn wl_client_for_each_resource(
        client: *mut wl_client,
        iterator: wl_client_for_each_resource_iterator_func_t,
        user_data: *mut ::core::ffi::c_void,
    );
}
pub type wl_user_data_destroy_func_t =
    ::core::option::Option<unsafe extern "C" fn(data: *mut ::core::ffi::c_void)>;
unsafe extern "C" {
    pub fn wl_client_set_user_data(
        client: *mut wl_client,
        data: *mut ::core::ffi::c_void,
        dtor: wl_user_data_destroy_func_t,
    );
}
unsafe extern "C" {
    pub fn wl_client_get_user_data(client: *mut wl_client) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn wl_client_set_max_buffer_size(client: *mut wl_client, max_buffer_size: usize);
}
#[doc = " \\class wl_listener\n\n \\brief A single listener for Wayland signals\n\n wl_listener provides the means to listen for wl_signal notifications. Many\n Wayland objects use wl_listener for notification of significant events like\n object destruction.\n\n Clients should create wl_listener objects manually and can register them as\n listeners to signals using #wl_signal_add, assuming the signal is\n directly accessible. For opaque structs like wl_event_loop, adding a\n listener should be done through provided accessor methods. A listener can\n only listen to one signal at a time.\n\n \\code\n struct wl_listener your_listener;\n\n your_listener.notify = your_callback_method;\n\n // Direct access\n wl_signal_add(&some_object->destroy_signal, &your_listener);\n\n // Accessor access\n wl_event_loop *loop = ...;\n wl_event_loop_add_destroy_listener(loop, &your_listener);\n \\endcode\n\n If the listener is part of a larger struct, #wl_container_of can be used\n to retrieve a pointer to it:\n\n \\code\n void your_listener(struct wl_listener *listener, void *data)\n {\n \tstruct your_data *data;\n\n \tyour_data = wl_container_of(listener, data, your_member_name);\n }\n \\endcode\n\n If you need to remove a listener from a signal, use wl_list_remove().\n\n \\code\n wl_list_remove(&your_listener.link);\n \\endcode\n\n \\sa wl_signal"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_listener"][::core::mem::size_of::<wl_listener>() - 24usize];
    ["Alignment of wl_listener"][::core::mem::align_of::<wl_listener>() - 8usize];
    ["Offset of field: wl_listener::link"][::core::mem::offset_of!(wl_listener, link) - 0usize];
    ["Offset of field: wl_listener::notify"]
        [::core::mem::offset_of!(wl_listener, notify) - 16usize];
};
#[doc = " \\class wl_signal\n\n \\brief A source of a type of observable event\n\n Signals are recognized points where significant events can be observed.\n Compositors as well as the server can provide signals. Observers are\n wl_listener's that are added through #wl_signal_add. Signals are emitted\n using #wl_signal_emit, which will invoke all listeners until that\n listener is removed by wl_list_remove() (or whenever the signal is\n destroyed).\n\n \\sa wl_listener for more information on using wl_signal"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_signal {
    pub listener_list: wl_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_signal"][::core::mem::size_of::<wl_signal>() - 16usize];
    ["Alignment of wl_signal"][::core::mem::align_of::<wl_signal>() - 8usize];
    ["Offset of field: wl_signal::listener_list"]
        [::core::mem::offset_of!(wl_signal, listener_list) - 0usize];
};
unsafe extern "C" {
    pub fn wl_signal_emit_mutable(signal: *mut wl_signal, data: *mut ::core::ffi::c_void);
}
pub type wl_resource_destroy_func_t =
    ::core::option::Option<unsafe extern "C" fn(resource: *mut wl_resource)>;
unsafe extern "C" {
    pub fn wl_resource_post_event(resource: *mut wl_resource, opcode: u32, ...);
}
unsafe extern "C" {
    pub fn wl_resource_post_event_array(
        resource: *mut wl_resource,
        opcode: u32,
        args: *mut wl_argument,
    );
}
unsafe extern "C" {
    pub fn wl_resource_queue_event(resource: *mut wl_resource, opcode: u32, ...);
}
unsafe extern "C" {
    pub fn wl_resource_queue_event_array(
        resource: *mut wl_resource,
        opcode: u32,
        args: *mut wl_argument,
    );
}
unsafe extern "C" {
    pub fn wl_resource_post_error(
        resource: *mut wl_resource,
        code: u32,
        msg: *const ::core::ffi::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn wl_resource_post_no_memory(resource: *mut wl_resource);
}
unsafe extern "C" {
    pub fn wl_client_get_display(client: *mut wl_client) -> *mut wl_display;
}
unsafe extern "C" {
    pub fn wl_resource_create(
        client: *mut wl_client,
        interface: *const wl_interface,
        version: ::core::ffi::c_int,
        id: u32,
    ) -> *mut wl_resource;
}
unsafe extern "C" {
    pub fn wl_resource_set_implementation(
        resource: *mut wl_resource,
        implementation: *const ::core::ffi::c_void,
        data: *mut ::core::ffi::c_void,
        destroy: wl_resource_destroy_func_t,
    );
}
unsafe extern "C" {
    pub fn wl_resource_set_dispatcher(
        resource: *mut wl_resource,
        dispatcher: wl_dispatcher_func_t,
        implementation: *const ::core::ffi::c_void,
        data: *mut ::core::ffi::c_void,
        destroy: wl_resource_destroy_func_t,
    );
}
unsafe extern "C" {
    pub fn wl_resource_destroy(resource: *mut wl_resource);
}
unsafe extern "C" {
    pub fn wl_resource_get_id(resource: *mut wl_resource) -> u32;
}
unsafe extern "C" {
    pub fn wl_resource_get_link(resource: *mut wl_resource) -> *mut wl_list;
}
unsafe extern "C" {
    pub fn wl_resource_from_link(resource: *mut wl_list) -> *mut wl_resource;
}
unsafe extern "C" {
    pub fn wl_resource_find_for_client(
        list: *mut wl_list,
        client: *mut wl_client,
    ) -> *mut wl_resource;
}
unsafe extern "C" {
    pub fn wl_resource_get_client(resource: *mut wl_resource) -> *mut wl_client;
}
unsafe extern "C" {
    pub fn wl_resource_set_user_data(resource: *mut wl_resource, data: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    pub fn wl_resource_get_user_data(resource: *mut wl_resource) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn wl_resource_get_version(resource: *mut wl_resource) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_resource_set_destructor(
        resource: *mut wl_resource,
        destroy: wl_resource_destroy_func_t,
    );
}
unsafe extern "C" {
    pub fn wl_resource_instance_of(
        resource: *mut wl_resource,
        interface: *const wl_interface,
        implementation: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_resource_get_class(resource: *mut wl_resource) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn wl_resource_add_destroy_listener(resource: *mut wl_resource, listener: *mut wl_listener);
}
unsafe extern "C" {
    pub fn wl_resource_get_destroy_listener(
        resource: *mut wl_resource,
        notify: wl_notify_func_t,
    ) -> *mut wl_listener;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_buffer {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn wl_shm_buffer_get(resource: *mut wl_resource) -> *mut wl_shm_buffer;
}
unsafe extern "C" {
    pub fn wl_shm_buffer_begin_access(buffer: *mut wl_shm_buffer);
}
unsafe extern "C" {
    pub fn wl_shm_buffer_end_access(buffer: *mut wl_shm_buffer);
}
unsafe extern "C" {
    pub fn wl_shm_buffer_get_data(buffer: *mut wl_shm_buffer) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn wl_shm_buffer_get_stride(buffer: *mut wl_shm_buffer) -> i32;
}
unsafe extern "C" {
    pub fn wl_shm_buffer_get_format(buffer: *mut wl_shm_buffer) -> u32;
}
unsafe extern "C" {
    pub fn wl_shm_buffer_get_width(buffer: *mut wl_shm_buffer) -> i32;
}
unsafe extern "C" {
    pub fn wl_shm_buffer_get_height(buffer: *mut wl_shm_buffer) -> i32;
}
unsafe extern "C" {
    pub fn wl_shm_buffer_ref_pool(buffer: *mut wl_shm_buffer) -> *mut wl_shm_pool;
}
unsafe extern "C" {
    pub fn wl_shm_pool_unref(pool: *mut wl_shm_pool);
}
unsafe extern "C" {
    pub fn wl_display_init_shm(display: *mut wl_display) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wl_display_add_shm_format(display: *mut wl_display, format: u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wl_shm_buffer_create(
        client: *mut wl_client,
        id: u32,
        width: i32,
        height: i32,
        stride: i32,
        format: u32,
    ) -> *mut wl_shm_buffer;
}
unsafe extern "C" {
    pub fn wl_log_set_handler_server(handler: wl_log_func_t);
}
pub const wl_protocol_logger_type_WL_PROTOCOL_LOGGER_REQUEST: wl_protocol_logger_type = 0;
pub const wl_protocol_logger_type_WL_PROTOCOL_LOGGER_EVENT: wl_protocol_logger_type = 1;
pub type wl_protocol_logger_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_protocol_logger_message {
    pub resource: *mut wl_resource,
    pub message_opcode: ::core::ffi::c_int,
    pub message: *const wl_message,
    pub arguments_count: ::core::ffi::c_int,
    pub arguments: *const wl_argument,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_protocol_logger_message"]
        [::core::mem::size_of::<wl_protocol_logger_message>() - 40usize];
    ["Alignment of wl_protocol_logger_message"]
        [::core::mem::align_of::<wl_protocol_logger_message>() - 8usize];
    ["Offset of field: wl_protocol_logger_message::resource"]
        [::core::mem::offset_of!(wl_protocol_logger_message, resource) - 0usize];
    ["Offset of field: wl_protocol_logger_message::message_opcode"]
        [::core::mem::offset_of!(wl_protocol_logger_message, message_opcode) - 8usize];
    ["Offset of field: wl_protocol_logger_message::message"]
        [::core::mem::offset_of!(wl_protocol_logger_message, message) - 16usize];
    ["Offset of field: wl_protocol_logger_message::arguments_count"]
        [::core::mem::offset_of!(wl_protocol_logger_message, arguments_count) - 24usize];
    ["Offset of field: wl_protocol_logger_message::arguments"]
        [::core::mem::offset_of!(wl_protocol_logger_message, arguments) - 32usize];
};
pub type wl_protocol_logger_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::core::ffi::c_void,
        direction: wl_protocol_logger_type,
        message: *const wl_protocol_logger_message,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_protocol_logger {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn wl_display_add_protocol_logger(
        display: *mut wl_display,
        arg1: wl_protocol_logger_func_t,
        user_data: *mut ::core::ffi::c_void,
    ) -> *mut wl_protocol_logger;
}
unsafe extern "C" {
    pub fn wl_protocol_logger_destroy(logger: *mut wl_protocol_logger);
}
#[doc = " \\class wl_object\n\n \\brief A protocol object.\n\n A `wl_object` is an opaque struct identifying the protocol object\n underlying a `wl_proxy` or `wl_resource`.\n\n \\note Functions accessing a `wl_object` are not normally used by client code.\n Clients should normally use the higher level interface generated by the\n scanner to interact with compositor objects.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_object {
    pub interface: *const wl_interface,
    pub implementation: *const ::core::ffi::c_void,
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_object"][::core::mem::size_of::<wl_object>() - 24usize];
    ["Alignment of wl_object"][::core::mem::align_of::<wl_object>() - 8usize];
    ["Offset of field: wl_object::interface"]
        [::core::mem::offset_of!(wl_object, interface) - 0usize];
    ["Offset of field: wl_object::implementation"]
        [::core::mem::offset_of!(wl_object, implementation) - 8usize];
    ["Offset of field: wl_object::id"][::core::mem::offset_of!(wl_object, id) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_resource {
    pub object: wl_object,
    pub destroy: wl_resource_destroy_func_t,
    pub link: wl_list,
    pub destroy_signal: wl_signal,
    pub client: *mut wl_client,
    pub data: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_resource"][::core::mem::size_of::<wl_resource>() - 80usize];
    ["Alignment of wl_resource"][::core::mem::align_of::<wl_resource>() - 8usize];
    ["Offset of field: wl_resource::object"][::core::mem::offset_of!(wl_resource, object) - 0usize];
    ["Offset of field: wl_resource::destroy"]
        [::core::mem::offset_of!(wl_resource, destroy) - 24usize];
    ["Offset of field: wl_resource::link"][::core::mem::offset_of!(wl_resource, link) - 32usize];
    ["Offset of field: wl_resource::destroy_signal"]
        [::core::mem::offset_of!(wl_resource, destroy_signal) - 48usize];
    ["Offset of field: wl_resource::client"]
        [::core::mem::offset_of!(wl_resource, client) - 64usize];
    ["Offset of field: wl_resource::data"][::core::mem::offset_of!(wl_resource, data) - 72usize];
};
unsafe extern "C" {
    pub fn wl_client_add_resource(client: *mut wl_client, resource: *mut wl_resource) -> u32;
}
unsafe extern "C" {
    pub fn wl_client_add_object(
        client: *mut wl_client,
        interface: *const wl_interface,
        implementation: *const ::core::ffi::c_void,
        id: u32,
        data: *mut ::core::ffi::c_void,
    ) -> *mut wl_resource;
}
unsafe extern "C" {
    pub fn wl_client_new_object(
        client: *mut wl_client,
        interface: *const wl_interface,
        implementation: *const ::core::ffi::c_void,
        data: *mut ::core::ffi::c_void,
    ) -> *mut wl_resource;
}
unsafe extern "C" {
    pub fn wl_display_add_global(
        display: *mut wl_display,
        interface: *const wl_interface,
        data: *mut ::core::ffi::c_void,
        bind: wl_global_bind_func_t,
    ) -> *mut wl_global;
}
unsafe extern "C" {
    pub fn wl_display_remove_global(display: *mut wl_display, global: *mut wl_global);
}
#[doc = " @ingroup iface_wl_display\n @struct wl_display_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_display_interface {
    #[doc = " asynchronous roundtrip\n\n The sync request asks the server to emit the 'done' event on\n the returned wl_callback object. Since requests are handled\n in-order and events are delivered in-order, this can be used as\n a barrier to ensure all previous requests and the resulting\n events have been handled.\n\n The object returned by this request will be destroyed by the\n compositor after the callback is fired and as such the client\n must not attempt to use it after that point.\n\n The callback_data passed in the callback is undefined and should\n be ignored.\n @param callback callback object for the sync request"]
    pub sync: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, callback: u32),
    >,
    #[doc = " get global registry object\n\n This request creates a registry object that allows the client\n to list and bind the global objects available from the\n compositor.\n\n It should be noted that the server side resources consumed in\n response to a get_registry request can only be released when the\n client disconnects, not when the client side proxy is destroyed.\n Therefore, clients should invoke get_registry as infrequently as\n possible to avoid wasting memory.\n @param registry global registry object"]
    pub get_registry: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, registry: u32),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_display_interface"][::core::mem::size_of::<wl_display_interface>() - 16usize];
    ["Alignment of wl_display_interface"][::core::mem::align_of::<wl_display_interface>() - 8usize];
    ["Offset of field: wl_display_interface::sync"]
        [::core::mem::offset_of!(wl_display_interface, sync) - 0usize];
    ["Offset of field: wl_display_interface::get_registry"]
        [::core::mem::offset_of!(wl_display_interface, get_registry) - 8usize];
};
#[doc = " @ingroup iface_wl_registry\n @struct wl_registry_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_registry_interface {
    #[doc = " bind an object to the display\n\n Binds a new, client-created object to the server using the\n specified name as the identifier.\n @param name unique numeric name of the object\n @param interface name of the objects interface\n @param version version of the objects interface\n @param id bounded object"]
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            name: u32,
            interface: *const ::core::ffi::c_char,
            version: u32,
            id: u32,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_registry_interface"][::core::mem::size_of::<wl_registry_interface>() - 8usize];
    ["Alignment of wl_registry_interface"]
        [::core::mem::align_of::<wl_registry_interface>() - 8usize];
    ["Offset of field: wl_registry_interface::bind"]
        [::core::mem::offset_of!(wl_registry_interface, bind) - 0usize];
};
#[doc = " @ingroup iface_wl_compositor\n @struct wl_compositor_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_compositor_interface {
    #[doc = " create new surface\n\n Ask the compositor to create a new surface.\n @param id the new surface"]
    pub create_surface: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    #[doc = " create new region\n\n Ask the compositor to create a new region.\n @param id the new region"]
    pub create_region: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_compositor_interface"]
        [::core::mem::size_of::<wl_compositor_interface>() - 16usize];
    ["Alignment of wl_compositor_interface"]
        [::core::mem::align_of::<wl_compositor_interface>() - 8usize];
    ["Offset of field: wl_compositor_interface::create_surface"]
        [::core::mem::offset_of!(wl_compositor_interface, create_surface) - 0usize];
    ["Offset of field: wl_compositor_interface::create_region"]
        [::core::mem::offset_of!(wl_compositor_interface, create_region) - 8usize];
};
#[doc = " @ingroup iface_wl_shm_pool\n @struct wl_shm_pool_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_pool_interface {
    #[doc = " create a buffer from the pool\n\n Create a wl_buffer object from the pool.\n\n The buffer is created offset bytes into the pool and has width\n and height as specified. The stride argument specifies the\n number of bytes from the beginning of one row to the beginning\n of the next. The format is the pixel format of the buffer and\n must be one of those advertised through the wl_shm.format event.\n\n A buffer will keep a reference to the pool it was created from\n so it is valid to destroy the pool immediately after creating a\n buffer from it.\n @param id buffer to create\n @param offset buffer byte offset within the pool\n @param width buffer width, in pixels\n @param height buffer height, in pixels\n @param stride number of bytes from the beginning of one row to the beginning of the next row\n @param format buffer pixel format"]
    pub create_buffer: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            offset: i32,
            width: i32,
            height: i32,
            stride: i32,
            format: u32,
        ),
    >,
    #[doc = " destroy the pool\n\n Destroy the shared memory pool.\n\n The mmapped memory will be released when all buffers that have\n been created from this pool are gone."]
    pub destroy: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " change the size of the pool mapping\n\n This request will cause the server to remap the backing memory\n for the pool from the file descriptor passed when the pool was\n created, but using the new size. This request can only be used\n to make the pool bigger.\n\n This request only changes the amount of bytes that are mmapped\n by the server and does not touch the file corresponding to the\n file descriptor passed at creation time. It is the client's\n responsibility to ensure that the file is at least as big as the\n new pool size.\n @param size new size of the pool, in bytes"]
    pub resize: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, size: i32),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_shm_pool_interface"][::core::mem::size_of::<wl_shm_pool_interface>() - 24usize];
    ["Alignment of wl_shm_pool_interface"]
        [::core::mem::align_of::<wl_shm_pool_interface>() - 8usize];
    ["Offset of field: wl_shm_pool_interface::create_buffer"]
        [::core::mem::offset_of!(wl_shm_pool_interface, create_buffer) - 0usize];
    ["Offset of field: wl_shm_pool_interface::destroy"]
        [::core::mem::offset_of!(wl_shm_pool_interface, destroy) - 8usize];
    ["Offset of field: wl_shm_pool_interface::resize"]
        [::core::mem::offset_of!(wl_shm_pool_interface, resize) - 16usize];
};
#[doc = " @ingroup iface_wl_shm\n @struct wl_shm_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_interface {
    #[doc = " create a shm pool\n\n Create a new wl_shm_pool object.\n\n The pool can be used to create shared memory based buffer\n objects. The server will mmap size bytes of the passed file\n descriptor, to use as backing memory for the pool.\n @param id pool to create\n @param fd file descriptor for the pool\n @param size pool size, in bytes"]
    pub create_pool: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            fd: i32,
            size: i32,
        ),
    >,
    #[doc = " release the shm object\n\n Using this request a client can tell the server that it is not\n going to use the shm object anymore.\n\n Objects created via this interface remain unaffected.\n @since 2"]
    pub release: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_shm_interface"][::core::mem::size_of::<wl_shm_interface>() - 16usize];
    ["Alignment of wl_shm_interface"][::core::mem::align_of::<wl_shm_interface>() - 8usize];
    ["Offset of field: wl_shm_interface::create_pool"]
        [::core::mem::offset_of!(wl_shm_interface, create_pool) - 0usize];
    ["Offset of field: wl_shm_interface::release"]
        [::core::mem::offset_of!(wl_shm_interface, release) - 8usize];
};
#[doc = " @ingroup iface_wl_buffer\n @struct wl_buffer_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_buffer_interface {
    #[doc = " destroy a buffer\n\n Destroy a buffer. If and how you need to release the backing\n storage is defined by the buffer factory interface.\n\n For possible side-effects to a surface, see wl_surface.attach."]
    pub destroy: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_buffer_interface"][::core::mem::size_of::<wl_buffer_interface>() - 8usize];
    ["Alignment of wl_buffer_interface"][::core::mem::align_of::<wl_buffer_interface>() - 8usize];
    ["Offset of field: wl_buffer_interface::destroy"]
        [::core::mem::offset_of!(wl_buffer_interface, destroy) - 0usize];
};
#[doc = " @ingroup iface_wl_data_offer\n @struct wl_data_offer_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_offer_interface {
    #[doc = " accept one of the offered mime types\n\n Indicate that the client can accept the given mime type, or\n NULL for not accepted.\n\n For objects of version 2 or older, this request is used by the\n client to give feedback whether the client can receive the given\n mime type, or NULL if none is accepted; the feedback does not\n determine whether the drag-and-drop operation succeeds or not.\n\n For objects of version 3 or newer, this request determines the\n final result of the drag-and-drop operation. If the end result\n is that no mime types were accepted, the drag-and-drop operation\n will be cancelled and the corresponding drag source will receive\n wl_data_source.cancelled. Clients may still use this event in\n conjunction with wl_data_source.action for feedback.\n @param serial serial number of the accept request\n @param mime_type mime type accepted by the client"]
    pub accept: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            serial: u32,
            mime_type: *const ::core::ffi::c_char,
        ),
    >,
    #[doc = " request that the data is transferred\n\n To transfer the offered data, the client issues this request\n and indicates the mime type it wants to receive. The transfer\n happens through the passed file descriptor (typically created\n with the pipe system call). The source client writes the data in\n the mime type representation requested and then closes the file\n descriptor.\n\n The receiving client reads from the read end of the pipe until\n EOF and then closes its end, at which point the transfer is\n complete.\n\n This request may happen multiple times for different mime types,\n both before and after wl_data_device.drop. Drag-and-drop\n destination clients may preemptively fetch data or examine it\n more closely to determine acceptance.\n @param mime_type mime type desired by receiver\n @param fd file descriptor for data transfer"]
    pub receive: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            mime_type: *const ::core::ffi::c_char,
            fd: i32,
        ),
    >,
    #[doc = " destroy data offer\n\n Destroy the data offer."]
    pub destroy: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " the offer will no longer be used\n\n Notifies the compositor that the drag destination successfully\n finished the drag-and-drop operation.\n\n Upon receiving this request, the compositor will emit\n wl_data_source.dnd_finished on the drag source client.\n\n It is a client error to perform other requests than\n wl_data_offer.destroy after this one. It is also an error to\n perform this request after a NULL mime type has been set in\n wl_data_offer.accept or no action was received through\n wl_data_offer.action.\n\n If wl_data_offer.finish request is received for a non drag and\n drop operation, the invalid_finish protocol error is raised.\n @since 3"]
    pub finish: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " set the available/preferred drag-and-drop actions\n\n Sets the actions that the destination side client supports for\n this operation. This request may trigger the emission of\n wl_data_source.action and wl_data_offer.action events if the\n compositor needs to change the selected action.\n\n This request can be called multiple times throughout the\n drag-and-drop operation, typically in response to\n wl_data_device.enter or wl_data_device.motion events.\n\n This request determines the final result of the drag-and-drop\n operation. If the end result is that no action is accepted, the\n drag source will receive wl_data_source.cancelled.\n\n The dnd_actions argument must contain only values expressed in\n the wl_data_device_manager.dnd_actions enum, and the\n preferred_action argument must only contain one of those values\n set, otherwise it will result in a protocol error.\n\n While managing an \"ask\" action, the destination drag-and-drop\n client may perform further wl_data_offer.receive requests, and\n is expected to perform one last wl_data_offer.set_actions\n request with a preferred action other than \"ask\" (and optionally\n wl_data_offer.accept) before requesting wl_data_offer.finish, in\n order to convey the action selected by the user. If the\n preferred action is not in the wl_data_offer.source_actions\n mask, an error will be raised.\n\n If the \"ask\" action is dismissed (e.g. user cancellation), the\n client is expected to perform wl_data_offer.destroy right away.\n\n This request can only be made on drag-and-drop offers, a\n protocol error will be raised otherwise.\n @param dnd_actions actions supported by the destination client\n @param preferred_action action preferred by the destination client\n @since 3"]
    pub set_actions: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            dnd_actions: u32,
            preferred_action: u32,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_data_offer_interface"]
        [::core::mem::size_of::<wl_data_offer_interface>() - 40usize];
    ["Alignment of wl_data_offer_interface"]
        [::core::mem::align_of::<wl_data_offer_interface>() - 8usize];
    ["Offset of field: wl_data_offer_interface::accept"]
        [::core::mem::offset_of!(wl_data_offer_interface, accept) - 0usize];
    ["Offset of field: wl_data_offer_interface::receive"]
        [::core::mem::offset_of!(wl_data_offer_interface, receive) - 8usize];
    ["Offset of field: wl_data_offer_interface::destroy"]
        [::core::mem::offset_of!(wl_data_offer_interface, destroy) - 16usize];
    ["Offset of field: wl_data_offer_interface::finish"]
        [::core::mem::offset_of!(wl_data_offer_interface, finish) - 24usize];
    ["Offset of field: wl_data_offer_interface::set_actions"]
        [::core::mem::offset_of!(wl_data_offer_interface, set_actions) - 32usize];
};
#[doc = " @ingroup iface_wl_data_source\n @struct wl_data_source_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_source_interface {
    #[doc = " add an offered mime type\n\n This request adds a mime type to the set of mime types\n advertised to targets. Can be called several times to offer\n multiple types.\n @param mime_type mime type offered by the data source"]
    pub offer: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            mime_type: *const ::core::ffi::c_char,
        ),
    >,
    #[doc = " destroy the data source\n\n Destroy the data source."]
    pub destroy: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " set the available drag-and-drop actions\n\n Sets the actions that the source side client supports for this\n operation. This request may trigger wl_data_source.action and\n wl_data_offer.action events if the compositor needs to change\n the selected action.\n\n The dnd_actions argument must contain only values expressed in\n the wl_data_device_manager.dnd_actions enum, otherwise it will\n result in a protocol error.\n\n This request must be made once only, and can only be made on\n sources used in drag-and-drop, so it must be performed before\n wl_data_device.start_drag. Attempting to use the source other\n than for drag-and-drop will raise a protocol error.\n @param dnd_actions actions supported by the data source\n @since 3"]
    pub set_actions: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, dnd_actions: u32),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_data_source_interface"]
        [::core::mem::size_of::<wl_data_source_interface>() - 24usize];
    ["Alignment of wl_data_source_interface"]
        [::core::mem::align_of::<wl_data_source_interface>() - 8usize];
    ["Offset of field: wl_data_source_interface::offer"]
        [::core::mem::offset_of!(wl_data_source_interface, offer) - 0usize];
    ["Offset of field: wl_data_source_interface::destroy"]
        [::core::mem::offset_of!(wl_data_source_interface, destroy) - 8usize];
    ["Offset of field: wl_data_source_interface::set_actions"]
        [::core::mem::offset_of!(wl_data_source_interface, set_actions) - 16usize];
};
#[doc = " @ingroup iface_wl_data_device\n @struct wl_data_device_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device_interface {
    #[doc = " start drag-and-drop operation\n\n This request asks the compositor to start a drag-and-drop\n operation on behalf of the client.\n\n The source argument is the data source that provides the data\n for the eventual data transfer. If source is NULL, enter, leave\n and motion events are sent only to the client that initiated the\n drag and the client is expected to handle the data passing\n internally. If source is destroyed, the drag-and-drop session\n will be cancelled.\n\n The origin surface is the surface where the drag originates and\n the client must have an active implicit grab that matches the\n serial.\n\n The icon surface is an optional (can be NULL) surface that\n provides an icon to be moved around with the cursor. Initially,\n the top-left corner of the icon surface is placed at the cursor\n hotspot, but subsequent wl_surface.offset requests can move the\n relative position. Attach requests must be confirmed with\n wl_surface.commit as usual. The icon surface is given the role\n of a drag-and-drop icon. If the icon surface already has another\n role, it raises a protocol error.\n\n The input region is ignored for wl_surfaces with the role of a\n drag-and-drop icon.\n\n The given source may not be used in any further set_selection or\n start_drag requests. Attempting to reuse a previously-used\n source may send a used_source error.\n @param source data source for the eventual transfer\n @param origin surface where the drag originates\n @param icon drag-and-drop icon surface\n @param serial serial number of the implicit grab on the origin"]
    pub start_drag: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            source: *mut wl_resource,
            origin: *mut wl_resource,
            icon: *mut wl_resource,
            serial: u32,
        ),
    >,
    #[doc = " copy data to the selection\n\n This request asks the compositor to set the selection to the\n data from the source on behalf of the client.\n\n To unset the selection, set the source to NULL.\n\n The given source may not be used in any further set_selection or\n start_drag requests. Attempting to reuse a previously-used\n source may send a used_source error.\n @param source data source for the selection\n @param serial serial number of the event that triggered this request"]
    pub set_selection: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            source: *mut wl_resource,
            serial: u32,
        ),
    >,
    #[doc = " destroy data device\n\n This request destroys the data device.\n @since 2"]
    pub release: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_data_device_interface"]
        [::core::mem::size_of::<wl_data_device_interface>() - 24usize];
    ["Alignment of wl_data_device_interface"]
        [::core::mem::align_of::<wl_data_device_interface>() - 8usize];
    ["Offset of field: wl_data_device_interface::start_drag"]
        [::core::mem::offset_of!(wl_data_device_interface, start_drag) - 0usize];
    ["Offset of field: wl_data_device_interface::set_selection"]
        [::core::mem::offset_of!(wl_data_device_interface, set_selection) - 8usize];
    ["Offset of field: wl_data_device_interface::release"]
        [::core::mem::offset_of!(wl_data_device_interface, release) - 16usize];
};
#[doc = " @ingroup iface_wl_data_device_manager\n @struct wl_data_device_manager_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device_manager_interface {
    #[doc = " create a new data source\n\n Create a new data source.\n @param id data source to create"]
    pub create_data_source: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    #[doc = " create a new data device\n\n Create a new data device for a given seat.\n @param id data device to create\n @param seat seat associated with the data device"]
    pub get_data_device: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            seat: *mut wl_resource,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_data_device_manager_interface"]
        [::core::mem::size_of::<wl_data_device_manager_interface>() - 16usize];
    ["Alignment of wl_data_device_manager_interface"]
        [::core::mem::align_of::<wl_data_device_manager_interface>() - 8usize];
    ["Offset of field: wl_data_device_manager_interface::create_data_source"]
        [::core::mem::offset_of!(wl_data_device_manager_interface, create_data_source) - 0usize];
    ["Offset of field: wl_data_device_manager_interface::get_data_device"]
        [::core::mem::offset_of!(wl_data_device_manager_interface, get_data_device) - 8usize];
};
#[doc = " @ingroup iface_wl_shell\n @struct wl_shell_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell_interface {
    #[doc = " create a shell surface from a surface\n\n Create a shell surface for an existing surface. This gives the\n wl_surface the role of a shell surface. If the wl_surface\n already has another role, it raises a protocol error.\n\n Only one shell surface can be associated with a given surface.\n @param id shell surface to create\n @param surface surface to be given the shell surface role"]
    pub get_shell_surface: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            surface: *mut wl_resource,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_shell_interface"][::core::mem::size_of::<wl_shell_interface>() - 8usize];
    ["Alignment of wl_shell_interface"][::core::mem::align_of::<wl_shell_interface>() - 8usize];
    ["Offset of field: wl_shell_interface::get_shell_surface"]
        [::core::mem::offset_of!(wl_shell_interface, get_shell_surface) - 0usize];
};
#[doc = " @ingroup iface_wl_shell_surface\n @struct wl_shell_surface_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell_surface_interface {
    #[doc = " respond to a ping event\n\n A client must respond to a ping event with a pong request or\n the client may be deemed unresponsive.\n @param serial serial number of the ping event"]
    pub pong: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, serial: u32),
    >,
    #[doc = " start an interactive move\n\n Start a pointer-driven move of the surface.\n\n This request must be used in response to a button press event.\n The server may ignore move requests depending on the state of\n the surface (e.g. fullscreen or maximized).\n @param seat seat whose pointer is used\n @param serial serial number of the implicit grab on the pointer"]
    pub move_: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            seat: *mut wl_resource,
            serial: u32,
        ),
    >,
    #[doc = " start an interactive resize\n\n Start a pointer-driven resizing of the surface.\n\n This request must be used in response to a button press event.\n The server may ignore resize requests depending on the state of\n the surface (e.g. fullscreen or maximized).\n @param seat seat whose pointer is used\n @param serial serial number of the implicit grab on the pointer\n @param edges which edge or corner is being dragged"]
    pub resize: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            seat: *mut wl_resource,
            serial: u32,
            edges: u32,
        ),
    >,
    #[doc = " make the surface a toplevel surface\n\n Map the surface as a toplevel surface.\n\n A toplevel surface is not fullscreen, maximized or transient."]
    pub set_toplevel: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " make the surface a transient surface\n\n Map the surface relative to an existing surface.\n\n The x and y arguments specify the location of the upper left\n corner of the surface relative to the upper left corner of the\n parent surface, in surface-local coordinates.\n\n The flags argument controls details of the transient behaviour.\n @param parent parent surface\n @param x surface-local x coordinate\n @param y surface-local y coordinate\n @param flags transient surface behavior"]
    pub set_transient: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            parent: *mut wl_resource,
            x: i32,
            y: i32,
            flags: u32,
        ),
    >,
    #[doc = " make the surface a fullscreen surface\n\n Map the surface as a fullscreen surface.\n\n If an output parameter is given then the surface will be made\n fullscreen on that output. If the client does not specify the\n output then the compositor will apply its policy - usually\n choosing the output on which the surface has the biggest surface\n area.\n\n The client may specify a method to resolve a size conflict\n between the output size and the surface size - this is provided\n through the method parameter.\n\n The framerate parameter is used only when the method is set to\n \"driver\", to indicate the preferred framerate. A value of 0\n indicates that the client does not care about framerate. The\n framerate is specified in mHz, that is framerate of 60000 is\n 60Hz.\n\n A method of \"scale\" or \"driver\" implies a scaling operation of\n the surface, either via a direct scaling operation or a change\n of the output mode. This will override any kind of output\n scaling, so that mapping a surface with a buffer size equal to\n the mode can fill the screen independent of buffer_scale.\n\n A method of \"fill\" means we don't scale up the buffer, however\n any output scale is applied. This means that you may run into an\n edge case where the application maps a buffer with the same size\n of the output mode but buffer_scale 1 (thus making a surface\n larger than the output). In this case it is allowed to downscale\n the results to fit the screen.\n\n The compositor must reply to this request with a configure event\n with the dimensions for the output on which the surface will be\n made fullscreen.\n @param method method for resolving size conflict\n @param framerate framerate in mHz\n @param output output on which the surface is to be fullscreen"]
    pub set_fullscreen: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            method: u32,
            framerate: u32,
            output: *mut wl_resource,
        ),
    >,
    #[doc = " make the surface a popup surface\n\n Map the surface as a popup.\n\n A popup surface is a transient surface with an added pointer\n grab.\n\n An existing implicit grab will be changed to owner-events mode,\n and the popup grab will continue after the implicit grab ends\n (i.e. releasing the mouse button does not cause the popup to be\n unmapped).\n\n The popup grab continues until the window is destroyed or a\n mouse button is pressed in any other client's window. A click in\n any of the client's surfaces is reported as normal, however,\n clicks in other clients' surfaces will be discarded and trigger\n the callback.\n\n The x and y arguments specify the location of the upper left\n corner of the surface relative to the upper left corner of the\n parent surface, in surface-local coordinates.\n @param seat seat whose pointer is used\n @param serial serial number of the implicit grab on the pointer\n @param parent parent surface\n @param x surface-local x coordinate\n @param y surface-local y coordinate\n @param flags transient surface behavior"]
    pub set_popup: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            seat: *mut wl_resource,
            serial: u32,
            parent: *mut wl_resource,
            x: i32,
            y: i32,
            flags: u32,
        ),
    >,
    #[doc = " make the surface a maximized surface\n\n Map the surface as a maximized surface.\n\n If an output parameter is given then the surface will be\n maximized on that output. If the client does not specify the\n output then the compositor will apply its policy - usually\n choosing the output on which the surface has the biggest surface\n area.\n\n The compositor will reply with a configure event telling the\n expected new surface size. The operation is completed on the\n next buffer attach to this surface.\n\n A maximized surface typically fills the entire output it is\n bound to, except for desktop elements such as panels. This is\n the main difference between a maximized shell surface and a\n fullscreen shell surface.\n\n The details depend on the compositor implementation.\n @param output output on which the surface is to be maximized"]
    pub set_maximized: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            output: *mut wl_resource,
        ),
    >,
    #[doc = " set surface title\n\n Set a short title for the surface.\n\n This string may be used to identify the surface in a task bar,\n window list, or other user interface elements provided by the\n compositor.\n\n The string must be encoded in UTF-8.\n @param title surface title"]
    pub set_title: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            title: *const ::core::ffi::c_char,
        ),
    >,
    #[doc = " set surface class\n\n Set a class for the surface.\n\n The surface class identifies the general class of applications\n to which the surface belongs. A common convention is to use the\n file name (or the full path if it is a non-standard location) of\n the application's .desktop file as the class.\n @param class_ surface class"]
    pub set_class: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            class_: *const ::core::ffi::c_char,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_shell_surface_interface"]
        [::core::mem::size_of::<wl_shell_surface_interface>() - 80usize];
    ["Alignment of wl_shell_surface_interface"]
        [::core::mem::align_of::<wl_shell_surface_interface>() - 8usize];
    ["Offset of field: wl_shell_surface_interface::pong"]
        [::core::mem::offset_of!(wl_shell_surface_interface, pong) - 0usize];
    ["Offset of field: wl_shell_surface_interface::move_"]
        [::core::mem::offset_of!(wl_shell_surface_interface, move_) - 8usize];
    ["Offset of field: wl_shell_surface_interface::resize"]
        [::core::mem::offset_of!(wl_shell_surface_interface, resize) - 16usize];
    ["Offset of field: wl_shell_surface_interface::set_toplevel"]
        [::core::mem::offset_of!(wl_shell_surface_interface, set_toplevel) - 24usize];
    ["Offset of field: wl_shell_surface_interface::set_transient"]
        [::core::mem::offset_of!(wl_shell_surface_interface, set_transient) - 32usize];
    ["Offset of field: wl_shell_surface_interface::set_fullscreen"]
        [::core::mem::offset_of!(wl_shell_surface_interface, set_fullscreen) - 40usize];
    ["Offset of field: wl_shell_surface_interface::set_popup"]
        [::core::mem::offset_of!(wl_shell_surface_interface, set_popup) - 48usize];
    ["Offset of field: wl_shell_surface_interface::set_maximized"]
        [::core::mem::offset_of!(wl_shell_surface_interface, set_maximized) - 56usize];
    ["Offset of field: wl_shell_surface_interface::set_title"]
        [::core::mem::offset_of!(wl_shell_surface_interface, set_title) - 64usize];
    ["Offset of field: wl_shell_surface_interface::set_class"]
        [::core::mem::offset_of!(wl_shell_surface_interface, set_class) - 72usize];
};
#[doc = " @ingroup iface_wl_surface\n @struct wl_surface_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_surface_interface {
    #[doc = " delete surface\n\n Deletes the surface and invalidates its object ID."]
    pub destroy: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " set the surface contents\n\n Set a buffer as the content of this surface.\n\n The new size of the surface is calculated based on the buffer\n size transformed by the inverse buffer_transform and the inverse\n buffer_scale. This means that at commit time the supplied buffer\n size must be an integer multiple of the buffer_scale. If that's\n not the case, an invalid_size error is sent.\n\n The x and y arguments specify the location of the new pending\n buffer's upper left corner, relative to the current buffer's\n upper left corner, in surface-local coordinates. In other words,\n the x and y, combined with the new surface size define in which\n directions the surface's size changes. Setting anything other\n than 0 as x and y arguments is discouraged, and should instead\n be replaced with using the separate wl_surface.offset request.\n\n When the bound wl_surface version is 5 or higher, passing any\n non-zero x or y is a protocol violation, and will result in an\n 'invalid_offset' error being raised. The x and y arguments are\n ignored and do not change the pending state. To achieve\n equivalent semantics, use wl_surface.offset.\n\n Surface contents are double-buffered state, see\n wl_surface.commit.\n\n The initial surface contents are void; there is no content.\n wl_surface.attach assigns the given wl_buffer as the pending\n wl_buffer. wl_surface.commit makes the pending wl_buffer the new\n surface contents, and the size of the surface becomes the size\n calculated from the wl_buffer, as described above. After commit,\n there is no pending buffer until the next attach.\n\n Committing a pending wl_buffer allows the compositor to read the\n pixels in the wl_buffer. The compositor may access the pixels at\n any time after the wl_surface.commit request. When the\n compositor will not access the pixels anymore, it will send the\n wl_buffer.release event. Only after receiving wl_buffer.release,\n the client may reuse the wl_buffer. A wl_buffer that has been\n attached and then replaced by another attach instead of\n committed will not receive a release event, and is not used by\n the compositor.\n\n If a pending wl_buffer has been committed to more than one\n wl_surface, the delivery of wl_buffer.release events becomes\n undefined. A well behaved client should not rely on\n wl_buffer.release events in this case. Alternatively, a client\n could create multiple wl_buffer objects from the same backing\n storage or use wp_linux_buffer_release.\n\n Destroying the wl_buffer after wl_buffer.release does not change\n the surface contents. Destroying the wl_buffer before\n wl_buffer.release is allowed as long as the underlying buffer\n storage isn't re-used (this can happen e.g. on client process\n termination). However, if the client destroys the wl_buffer\n before receiving the wl_buffer.release event and mutates the\n underlying buffer storage, the surface contents become undefined\n immediately.\n\n If wl_surface.attach is sent with a NULL wl_buffer, the\n following wl_surface.commit will remove the surface content.\n\n If a pending wl_buffer has been destroyed, the result is not\n specified. Many compositors are known to remove the surface\n content on the following wl_surface.commit, but this behaviour\n is not universal. Clients seeking to maximise compatibility\n should not destroy pending buffers and should ensure that they\n explicitly remove content from surfaces, even after destroying\n buffers.\n @param buffer buffer of surface contents\n @param x surface-local x coordinate\n @param y surface-local y coordinate"]
    pub attach: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            buffer: *mut wl_resource,
            x: i32,
            y: i32,
        ),
    >,
    #[doc = " mark part of the surface damaged\n\n This request is used to describe the regions where the pending\n buffer is different from the current surface contents, and where\n the surface therefore needs to be repainted. The compositor\n ignores the parts of the damage that fall outside of the\n surface.\n\n Damage is double-buffered state, see wl_surface.commit.\n\n The damage rectangle is specified in surface-local coordinates,\n where x and y specify the upper left corner of the damage\n rectangle.\n\n The initial value for pending damage is empty: no damage.\n wl_surface.damage adds pending damage: the new pending damage is\n the union of old pending damage and the given rectangle.\n\n wl_surface.commit assigns pending damage as the current damage,\n and clears pending damage. The server will clear the current\n damage as it repaints the surface.\n\n Note! New clients should not use this request. Instead damage\n can be posted with wl_surface.damage_buffer which uses buffer\n coordinates instead of surface coordinates.\n @param x surface-local x coordinate\n @param y surface-local y coordinate\n @param width width of damage rectangle\n @param height height of damage rectangle"]
    pub damage: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ),
    >,
    #[doc = " request a frame throttling hint\n\n Request a notification when it is a good time to start drawing\n a new frame, by creating a frame callback. This is useful for\n throttling redrawing operations, and driving animations.\n\n When a client is animating on a wl_surface, it can use the\n 'frame' request to get notified when it is a good time to draw\n and commit the next frame of animation. If the client commits an\n update earlier than that, it is likely that some updates will\n not make it to the display, and the client is wasting resources\n by drawing too often.\n\n The frame request will take effect on the next\n wl_surface.commit. The notification will only be posted for one\n frame unless requested again. For a wl_surface, the\n notifications are posted in the order the frame requests were\n committed.\n\n The server must send the notifications so that a client will not\n send excessive updates, while still allowing the highest\n possible update rate for clients that wait for the reply before\n drawing again. The server should give some time for the client\n to draw and commit after sending the frame callback events to\n let it hit the next output refresh.\n\n A server should avoid signaling the frame callbacks if the\n surface is not visible in any way, e.g. the surface is\n off-screen, or completely obscured by other opaque surfaces.\n\n The object returned by this request will be destroyed by the\n compositor after the callback is fired and as such the client\n must not attempt to use it after that point.\n\n The callback_data passed in the callback is the current time, in\n milliseconds, with an undefined base.\n @param callback callback object for the frame request"]
    pub frame: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, callback: u32),
    >,
    #[doc = " set opaque region\n\n This request sets the region of the surface that contains\n opaque content.\n\n The opaque region is an optimization hint for the compositor\n that lets it optimize the redrawing of content behind opaque\n regions. Setting an opaque region is not required for correct\n behaviour, but marking transparent content as opaque will result\n in repaint artifacts.\n\n The opaque region is specified in surface-local coordinates.\n\n The compositor ignores the parts of the opaque region that fall\n outside of the surface.\n\n Opaque region is double-buffered state, see wl_surface.commit.\n\n wl_surface.set_opaque_region changes the pending opaque region.\n wl_surface.commit copies the pending region to the current\n region. Otherwise, the pending and current regions are never\n changed.\n\n The initial value for an opaque region is empty. Setting the\n pending opaque region has copy semantics, and the wl_region\n object can be destroyed immediately. A NULL wl_region causes the\n pending opaque region to be set to empty.\n @param region opaque region of the surface"]
    pub set_opaque_region: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            region: *mut wl_resource,
        ),
    >,
    #[doc = " set input region\n\n This request sets the region of the surface that can receive\n pointer and touch events.\n\n Input events happening outside of this region will try the next\n surface in the server surface stack. The compositor ignores the\n parts of the input region that fall outside of the surface.\n\n The input region is specified in surface-local coordinates.\n\n Input region is double-buffered state, see wl_surface.commit.\n\n wl_surface.set_input_region changes the pending input region.\n wl_surface.commit copies the pending region to the current\n region. Otherwise the pending and current regions are never\n changed, except cursor and icon surfaces are special cases, see\n wl_pointer.set_cursor and wl_data_device.start_drag.\n\n The initial value for an input region is infinite. That means\n the whole surface will accept input. Setting the pending input\n region has copy semantics, and the wl_region object can be\n destroyed immediately. A NULL wl_region causes the input region\n to be set to infinite.\n @param region input region of the surface"]
    pub set_input_region: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            region: *mut wl_resource,
        ),
    >,
    #[doc = " commit pending surface state\n\n Surface state (input, opaque, and damage regions, attached\n buffers, etc.) is double-buffered. Protocol requests modify the\n pending state, as opposed to the active state in use by the\n compositor.\n\n A commit request atomically creates a content update from the\n pending state, even if the pending state has not been touched.\n The content update is placed in a queue until it becomes active.\n After commit, the new pending state is as documented for each\n related request.\n\n When the content update is applied, the wl_buffer is applied\n before all other state. This means that all coordinates in\n double-buffered state are relative to the newly attached\n wl_buffers, except for wl_surface.attach itself. If there is no\n newly attached wl_buffer, the coordinates are relative to the\n previous content update.\n\n All requests that need a commit to become effective are\n documented to affect double-buffered state.\n\n Other interfaces may add further double-buffered surface state."]
    pub commit: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " sets the buffer transformation\n\n This request sets the transformation that the client has\n already applied to the content of the buffer. The accepted\n values for the transform parameter are the values for\n wl_output.transform.\n\n The compositor applies the inverse of this transformation\n whenever it uses the buffer contents.\n\n Buffer transform is double-buffered state, see\n wl_surface.commit.\n\n A newly created surface has its buffer transformation set to\n normal.\n\n wl_surface.set_buffer_transform changes the pending buffer\n transformation. wl_surface.commit copies the pending buffer\n transformation to the current one. Otherwise, the pending and\n current values are never changed.\n\n The purpose of this request is to allow clients to render\n content according to the output transform, thus permitting the\n compositor to use certain optimizations even if the display is\n rotated. Using hardware overlays and scanning out a client\n buffer for fullscreen surfaces are examples of such\n optimizations. Those optimizations are highly dependent on the\n compositor implementation, so the use of this request should be\n considered on a case-by-case basis.\n\n Note that if the transform value includes 90 or 270 degree\n rotation, the width of the buffer will become the surface height\n and the height of the buffer will become the surface width.\n\n If transform is not one of the values from the\n wl_output.transform enum the invalid_transform protocol error is\n raised.\n @param transform transform for interpreting buffer contents\n @since 2"]
    pub set_buffer_transform: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, transform: i32),
    >,
    #[doc = " sets the buffer scaling factor\n\n This request sets an optional scaling factor on how the\n compositor interprets the contents of the buffer attached to the\n window.\n\n Buffer scale is double-buffered state, see wl_surface.commit.\n\n A newly created surface has its buffer scale set to 1.\n\n wl_surface.set_buffer_scale changes the pending buffer scale.\n wl_surface.commit copies the pending buffer scale to the current\n one. Otherwise, the pending and current values are never\n changed.\n\n The purpose of this request is to allow clients to supply higher\n resolution buffer data for use on high resolution outputs. It is\n intended that you pick the same buffer scale as the scale of the\n output that the surface is displayed on. This means the\n compositor can avoid scaling when rendering the surface on that\n output.\n\n Note that if the scale is larger than 1, then you have to attach\n a buffer that is larger (by a factor of scale in each dimension)\n than the desired surface size.\n\n If scale is not greater than 0 the invalid_scale protocol error\n is raised.\n @param scale scale for interpreting buffer contents\n @since 3"]
    pub set_buffer_scale: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, scale: i32),
    >,
    #[doc = " mark part of the surface damaged using buffer coordinates\n\n This request is used to describe the regions where the pending\n buffer is different from the current surface contents, and where\n the surface therefore needs to be repainted. The compositor\n ignores the parts of the damage that fall outside of the\n surface.\n\n Damage is double-buffered state, see wl_surface.commit.\n\n The damage rectangle is specified in buffer coordinates, where x\n and y specify the upper left corner of the damage rectangle.\n\n The initial value for pending damage is empty: no damage.\n wl_surface.damage_buffer adds pending damage: the new pending\n damage is the union of old pending damage and the given\n rectangle.\n\n wl_surface.commit assigns pending damage as the current damage,\n and clears pending damage. The server will clear the current\n damage as it repaints the surface.\n\n This request differs from wl_surface.damage in only one way - it\n takes damage in buffer coordinates instead of surface-local\n coordinates. While this generally is more intuitive than surface\n coordinates, it is especially desirable when using wp_viewport\n or when a drawing library (like EGL) is unaware of buffer scale\n and buffer transform.\n\n Note: Because buffer transformation changes and damage requests\n may be interleaved in the protocol stream, it is impossible to\n determine the actual mapping between surface and buffer damage\n until wl_surface.commit time. Therefore, compositors wishing to\n take both kinds of damage into account will have to accumulate\n damage from the two requests separately and only transform from\n one to the other after receiving the wl_surface.commit.\n @param x buffer-local x coordinate\n @param y buffer-local y coordinate\n @param width width of damage rectangle\n @param height height of damage rectangle\n @since 4"]
    pub damage_buffer: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ),
    >,
    #[doc = " set the surface contents offset\n\n The x and y arguments specify the location of the new pending\n buffer's upper left corner, relative to the current buffer's\n upper left corner, in surface-local coordinates. In other words,\n the x and y, combined with the new surface size define in which\n directions the surface's size changes.\n\n Surface location offset is double-buffered state, see\n wl_surface.commit.\n\n This request is semantically equivalent to and the replaces the\n x and y arguments in the wl_surface.attach request in wl_surface\n versions prior to 5. See wl_surface.attach for details.\n @param x surface-local x coordinate\n @param y surface-local y coordinate\n @since 5"]
    pub offset: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, x: i32, y: i32),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_surface_interface"][::core::mem::size_of::<wl_surface_interface>() - 88usize];
    ["Alignment of wl_surface_interface"][::core::mem::align_of::<wl_surface_interface>() - 8usize];
    ["Offset of field: wl_surface_interface::destroy"]
        [::core::mem::offset_of!(wl_surface_interface, destroy) - 0usize];
    ["Offset of field: wl_surface_interface::attach"]
        [::core::mem::offset_of!(wl_surface_interface, attach) - 8usize];
    ["Offset of field: wl_surface_interface::damage"]
        [::core::mem::offset_of!(wl_surface_interface, damage) - 16usize];
    ["Offset of field: wl_surface_interface::frame"]
        [::core::mem::offset_of!(wl_surface_interface, frame) - 24usize];
    ["Offset of field: wl_surface_interface::set_opaque_region"]
        [::core::mem::offset_of!(wl_surface_interface, set_opaque_region) - 32usize];
    ["Offset of field: wl_surface_interface::set_input_region"]
        [::core::mem::offset_of!(wl_surface_interface, set_input_region) - 40usize];
    ["Offset of field: wl_surface_interface::commit"]
        [::core::mem::offset_of!(wl_surface_interface, commit) - 48usize];
    ["Offset of field: wl_surface_interface::set_buffer_transform"]
        [::core::mem::offset_of!(wl_surface_interface, set_buffer_transform) - 56usize];
    ["Offset of field: wl_surface_interface::set_buffer_scale"]
        [::core::mem::offset_of!(wl_surface_interface, set_buffer_scale) - 64usize];
    ["Offset of field: wl_surface_interface::damage_buffer"]
        [::core::mem::offset_of!(wl_surface_interface, damage_buffer) - 72usize];
    ["Offset of field: wl_surface_interface::offset"]
        [::core::mem::offset_of!(wl_surface_interface, offset) - 80usize];
};
#[doc = " @ingroup iface_wl_seat\n @struct wl_seat_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_seat_interface {
    #[doc = " return pointer object\n\n The ID provided will be initialized to the wl_pointer\n interface for this seat.\n\n This request only takes effect if the seat has the pointer\n capability, or has had the pointer capability in the past. It is\n a protocol violation to issue this request on a seat that has\n never had the pointer capability. The missing_capability error\n will be sent in this case.\n @param id seat pointer"]
    pub get_pointer: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    #[doc = " return keyboard object\n\n The ID provided will be initialized to the wl_keyboard\n interface for this seat.\n\n This request only takes effect if the seat has the keyboard\n capability, or has had the keyboard capability in the past. It\n is a protocol violation to issue this request on a seat that has\n never had the keyboard capability. The missing_capability error\n will be sent in this case.\n @param id seat keyboard"]
    pub get_keyboard: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    #[doc = " return touch object\n\n The ID provided will be initialized to the wl_touch interface\n for this seat.\n\n This request only takes effect if the seat has the touch\n capability, or has had the touch capability in the past. It is a\n protocol violation to issue this request on a seat that has\n never had the touch capability. The missing_capability error\n will be sent in this case.\n @param id seat touch interface"]
    pub get_touch: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    #[doc = " release the seat object\n\n Using this request a client can tell the server that it is not\n going to use the seat object anymore.\n @since 5"]
    pub release: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_seat_interface"][::core::mem::size_of::<wl_seat_interface>() - 32usize];
    ["Alignment of wl_seat_interface"][::core::mem::align_of::<wl_seat_interface>() - 8usize];
    ["Offset of field: wl_seat_interface::get_pointer"]
        [::core::mem::offset_of!(wl_seat_interface, get_pointer) - 0usize];
    ["Offset of field: wl_seat_interface::get_keyboard"]
        [::core::mem::offset_of!(wl_seat_interface, get_keyboard) - 8usize];
    ["Offset of field: wl_seat_interface::get_touch"]
        [::core::mem::offset_of!(wl_seat_interface, get_touch) - 16usize];
    ["Offset of field: wl_seat_interface::release"]
        [::core::mem::offset_of!(wl_seat_interface, release) - 24usize];
};
#[doc = " @ingroup iface_wl_pointer\n @struct wl_pointer_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_pointer_interface {
    #[doc = " set the pointer surface\n\n Set the pointer surface, i.e., the surface that contains the\n pointer image (cursor). This request gives the surface the role\n of a cursor. If the surface already has another role, it raises\n a protocol error.\n\n The cursor actually changes only if the pointer focus for this\n device is one of the requesting client's surfaces or the surface\n parameter is the current pointer surface. If there was a\n previous surface set with this request it is replaced. If\n surface is NULL, the pointer image is hidden.\n\n The parameters hotspot_x and hotspot_y define the position of\n the pointer surface relative to the pointer location. Its\n top-left corner is always at (x, y) - (hotspot_x, hotspot_y),\n where (x, y) are the coordinates of the pointer location, in\n surface-local coordinates.\n\n On wl_surface.offset requests to the pointer surface, hotspot_x\n and hotspot_y are decremented by the x and y parameters passed\n to the request. The offset must be applied by wl_surface.commit\n as usual.\n\n The hotspot can also be updated by passing the currently set\n pointer surface to this request with new values for hotspot_x\n and hotspot_y.\n\n The input region is ignored for wl_surfaces with the role of a\n cursor. When the use as a cursor ends, the wl_surface is\n unmapped.\n\n The serial parameter must match the latest wl_pointer.enter\n serial number sent to the client. Otherwise the request will be\n ignored.\n @param serial serial number of the enter event\n @param surface pointer surface\n @param hotspot_x surface-local x coordinate\n @param hotspot_y surface-local y coordinate"]
    pub set_cursor: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            serial: u32,
            surface: *mut wl_resource,
            hotspot_x: i32,
            hotspot_y: i32,
        ),
    >,
    #[doc = " release the pointer object\n\n Using this request a client can tell the server that it is not\n going to use the pointer object anymore.\n\n This request destroys the pointer proxy object, so clients must\n not call wl_pointer_destroy() after using this request.\n @since 3"]
    pub release: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_pointer_interface"][::core::mem::size_of::<wl_pointer_interface>() - 16usize];
    ["Alignment of wl_pointer_interface"][::core::mem::align_of::<wl_pointer_interface>() - 8usize];
    ["Offset of field: wl_pointer_interface::set_cursor"]
        [::core::mem::offset_of!(wl_pointer_interface, set_cursor) - 0usize];
    ["Offset of field: wl_pointer_interface::release"]
        [::core::mem::offset_of!(wl_pointer_interface, release) - 8usize];
};
#[doc = " @ingroup iface_wl_keyboard\n @struct wl_keyboard_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_keyboard_interface {
    #[doc = " release the keyboard object\n\n\n @since 3"]
    pub release: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_keyboard_interface"][::core::mem::size_of::<wl_keyboard_interface>() - 8usize];
    ["Alignment of wl_keyboard_interface"]
        [::core::mem::align_of::<wl_keyboard_interface>() - 8usize];
    ["Offset of field: wl_keyboard_interface::release"]
        [::core::mem::offset_of!(wl_keyboard_interface, release) - 0usize];
};
#[doc = " @ingroup iface_wl_touch\n @struct wl_touch_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_touch_interface {
    #[doc = " release the touch object\n\n\n @since 3"]
    pub release: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_touch_interface"][::core::mem::size_of::<wl_touch_interface>() - 8usize];
    ["Alignment of wl_touch_interface"][::core::mem::align_of::<wl_touch_interface>() - 8usize];
    ["Offset of field: wl_touch_interface::release"]
        [::core::mem::offset_of!(wl_touch_interface, release) - 0usize];
};
#[doc = " @ingroup iface_wl_output\n @struct wl_output_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_output_interface {
    #[doc = " release the output object\n\n Using this request a client can tell the server that it is not\n going to use the output object anymore.\n @since 3"]
    pub release: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_output_interface"][::core::mem::size_of::<wl_output_interface>() - 8usize];
    ["Alignment of wl_output_interface"][::core::mem::align_of::<wl_output_interface>() - 8usize];
    ["Offset of field: wl_output_interface::release"]
        [::core::mem::offset_of!(wl_output_interface, release) - 0usize];
};
#[doc = " @ingroup iface_wl_region\n @struct wl_region_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_region_interface {
    #[doc = " destroy region\n\n Destroy the region. This will invalidate the object ID."]
    pub destroy: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " add rectangle to region\n\n Add the specified rectangle to the region.\n @param x region-local x coordinate\n @param y region-local y coordinate\n @param width rectangle width\n @param height rectangle height"]
    pub add: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ),
    >,
    #[doc = " subtract rectangle from region\n\n Subtract the specified rectangle from the region.\n @param x region-local x coordinate\n @param y region-local y coordinate\n @param width rectangle width\n @param height rectangle height"]
    pub subtract: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_region_interface"][::core::mem::size_of::<wl_region_interface>() - 24usize];
    ["Alignment of wl_region_interface"][::core::mem::align_of::<wl_region_interface>() - 8usize];
    ["Offset of field: wl_region_interface::destroy"]
        [::core::mem::offset_of!(wl_region_interface, destroy) - 0usize];
    ["Offset of field: wl_region_interface::add"]
        [::core::mem::offset_of!(wl_region_interface, add) - 8usize];
    ["Offset of field: wl_region_interface::subtract"]
        [::core::mem::offset_of!(wl_region_interface, subtract) - 16usize];
};
#[doc = " @ingroup iface_wl_subcompositor\n @struct wl_subcompositor_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_subcompositor_interface {
    #[doc = " unbind from the subcompositor interface\n\n Informs the server that the client will not be using this\n protocol object anymore. This does not affect any other objects,\n wl_subsurface objects included."]
    pub destroy: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " give a surface the role sub-surface\n\n Create a sub-surface interface for the given surface, and\n associate it with the given parent surface. This turns a plain\n wl_surface into a sub-surface.\n\n The to-be sub-surface must not already have another role, and it\n must not have an existing wl_subsurface object. Otherwise the\n bad_surface protocol error is raised.\n\n Adding sub-surfaces to a parent is a double-buffered operation\n on the parent (see wl_surface.commit). The effect of adding a\n sub-surface becomes visible on the next time the state of the\n parent surface is applied.\n\n The parent surface must not be one of the child surface's\n descendants, and the parent must be different from the child\n surface, otherwise the bad_parent protocol error is raised.\n\n This request modifies the behaviour of wl_surface.commit request\n on the sub-surface, see the documentation on wl_subsurface\n interface.\n @param id the new sub-surface object ID\n @param surface the surface to be turned into a sub-surface\n @param parent the parent surface"]
    pub get_subsurface: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            surface: *mut wl_resource,
            parent: *mut wl_resource,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_subcompositor_interface"]
        [::core::mem::size_of::<wl_subcompositor_interface>() - 16usize];
    ["Alignment of wl_subcompositor_interface"]
        [::core::mem::align_of::<wl_subcompositor_interface>() - 8usize];
    ["Offset of field: wl_subcompositor_interface::destroy"]
        [::core::mem::offset_of!(wl_subcompositor_interface, destroy) - 0usize];
    ["Offset of field: wl_subcompositor_interface::get_subsurface"]
        [::core::mem::offset_of!(wl_subcompositor_interface, get_subsurface) - 8usize];
};
#[doc = " @ingroup iface_wl_subsurface\n @struct wl_subsurface_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_subsurface_interface {
    #[doc = " remove sub-surface interface\n\n The sub-surface interface is removed from the wl_surface\n object that was turned into a sub-surface with a\n wl_subcompositor.get_subsurface request. The wl_surface's\n association to the parent is deleted. The wl_surface is unmapped\n immediately."]
    pub destroy: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " reposition the sub-surface\n\n This schedules a sub-surface position change. The sub-surface\n will be moved so that its origin (top left corner pixel) will be\n at the location x, y of the parent surface coordinate system.\n The coordinates are not restricted to the parent surface area.\n Negative values are allowed.\n\n The scheduled coordinates will take effect whenever the state of\n the parent surface is applied.\n\n If more than one set_position request is invoked by the client\n before the commit of the parent surface, the position of a new\n request always replaces the scheduled position from any previous\n request.\n\n The initial position is 0, 0.\n @param x x coordinate in the parent surface\n @param y y coordinate in the parent surface"]
    pub set_position: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, x: i32, y: i32),
    >,
    #[doc = " restack the sub-surface\n\n This sub-surface is taken from the stack, and put back just\n above the reference surface, changing the z-order of the\n sub-surfaces. The reference surface must be one of the sibling\n surfaces, or the parent surface. Using any other surface,\n including this sub-surface, will cause a protocol error.\n\n The z-order is double-buffered. Requests are handled in order\n and applied immediately to a pending state. The final pending\n state is copied to the active state the next time the state of\n the parent surface is applied.\n\n A new sub-surface is initially added as the top-most in the\n stack of its siblings and parent.\n @param sibling the reference surface"]
    pub place_above: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            sibling: *mut wl_resource,
        ),
    >,
    #[doc = " restack the sub-surface\n\n The sub-surface is placed just below the reference surface.\n See wl_subsurface.place_above.\n @param sibling the reference surface"]
    pub place_below: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            sibling: *mut wl_resource,
        ),
    >,
    #[doc = " set sub-surface to synchronized mode\n\n Change the commit behaviour of the sub-surface to synchronized\n mode, also described as the parent dependent mode.\n\n In synchronized mode, wl_surface.commit on a sub-surface will\n accumulate the committed state in a cache, but the state will\n not be applied and hence will not change the compositor output.\n The cached state is applied to the sub-surface immediately after\n the parent surface's state is applied. This ensures atomic\n updates of the parent and all its synchronized sub-surfaces.\n Applying the cached state will invalidate the cache, so further\n parent surface commits do not (re-)apply old state.\n\n See wl_subsurface for the recursive effect of this mode."]
    pub set_sync: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " set sub-surface to desynchronized mode\n\n Change the commit behaviour of the sub-surface to\n desynchronized mode, also described as independent or freely\n running mode.\n\n In desynchronized mode, wl_surface.commit on a sub-surface will\n apply the pending state directly, without caching, as happens\n normally with a wl_surface. Calling wl_surface.commit on the\n parent surface has no effect on the sub-surface's wl_surface\n state. This mode allows a sub-surface to be updated on its own.\n\n If cached state exists when wl_surface.commit is called in\n desynchronized mode, the pending state is added to the cached\n state, and applied as a whole. This invalidates the cache.\n\n Note: even if a sub-surface is set to desynchronized, a parent\n sub-surface may override it to behave as synchronized. For\n details, see wl_subsurface.\n\n If a surface's parent surface behaves as desynchronized, then\n the cached state is applied on set_desync."]
    pub set_desync: ::core::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wl_subsurface_interface"]
        [::core::mem::size_of::<wl_subsurface_interface>() - 48usize];
    ["Alignment of wl_subsurface_interface"]
        [::core::mem::align_of::<wl_subsurface_interface>() - 8usize];
    ["Offset of field: wl_subsurface_interface::destroy"]
        [::core::mem::offset_of!(wl_subsurface_interface, destroy) - 0usize];
    ["Offset of field: wl_subsurface_interface::set_position"]
        [::core::mem::offset_of!(wl_subsurface_interface, set_position) - 8usize];
    ["Offset of field: wl_subsurface_interface::place_above"]
        [::core::mem::offset_of!(wl_subsurface_interface, place_above) - 16usize];
    ["Offset of field: wl_subsurface_interface::place_below"]
        [::core::mem::offset_of!(wl_subsurface_interface, place_below) - 24usize];
    ["Offset of field: wl_subsurface_interface::set_sync"]
        [::core::mem::offset_of!(wl_subsurface_interface, set_sync) - 32usize];
    ["Offset of field: wl_subsurface_interface::set_desync"]
        [::core::mem::offset_of!(wl_subsurface_interface, set_desync) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_egl_window {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn wl_egl_window_create(
        surface: *mut wl_surface,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) -> *mut wl_egl_window;
}
unsafe extern "C" {
    pub fn wl_egl_window_destroy(egl_window: *mut wl_egl_window);
}
unsafe extern "C" {
    pub fn wl_egl_window_resize(
        egl_window: *mut wl_egl_window,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        dx: ::core::ffi::c_int,
        dy: ::core::ffi::c_int,
    );
}
unsafe extern "C" {
    pub fn wl_egl_window_get_attached_size(
        egl_window: *mut wl_egl_window,
        width: *mut ::core::ffi::c_int,
        height: *mut ::core::ffi::c_int,
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::core::ffi::c_uint,
    pub fp_offset: ::core::ffi::c_uint,
    pub overflow_arg_area: *mut ::core::ffi::c_void,
    pub reg_save_area: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::core::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::core::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::core::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::core::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::core::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::core::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
